//package

// import flash.display.*;
// import flash.ui.Keyboard;
// import flash.events.*;
// import flash.text.*;
// import flash.geom.Point;
// import flash.utils.Timer;
// import fl.controls.ComboBox;
// import flash.ui.Mouse;
// import flash.net.FileReference;
// import fl.data.DataProvider;
// import flash.filters.BlurFilter;
// import flash.filters.ColorMatrixFilter;
// import flash.geom.Matrix;
// import flash.ui.MouseCursor;
// import flash.display.Bitmap;
// import flash.display.BitmapData;
// import flash.geom.Rectangle;
// import fl.events.ListEvent;

import * as PIXI from "pixi.js";

//O import com.partKart.*;
import Global from "./com/partKart/Global";
import { Segment } from "./com/partKart/Segment";
import { Grid } from "./com/partKart/Grid";
import { Tab } from "./com/partKart/Tab";
import { Individual } from "./com/partKart/Individual";
import { Undo } from "./com/partKart/Undo";

//O import com.lorentz.SVG.*;
import { PathCommand } from "./com/lorentz/SVG/PathCommand";
import { StringUtil } from "./com/lorentz/SVG/StringUtil";
import { SVGColor } from "./com/lorentz/SVG/SVColor";

public class Main extends PIXI.Sprite
{

   private grid:Grid;

   public scene: SceneGraph;

   private background: PIXI.Sprite;   // background image
   private backgroundscale: number = 72;
   private backgroundvisibility: number = 50;

   public xstart: number = 0;
   public ystart: number = 0;

   private dragging: boolean = false;

   private xoriginstart: number;
   private yoriginstart: number;

   private sketch: Sketch;  // draw one sketch at a time
   private sketchdot:Dot;   // currently active sketchdot for path joining after sketch operation

   private pen: Pen;
   private pendot: Dot;

   // the imposter "pretends" to be the scene graph during zoom operations, this makes the app more responsive with extremely complex files
   private imposter: PIXI.Sprite;

   // flag used to indicate that a zoom operation is in progress
   private zooming: boolean = false;
   private startzoom: number;

   private now: number = 0;
   private timer: Timer;

   // temporary holder for the tool number while we display a modal dialog
   private temptool: number = 0;

   private file: FileReference;
   private progressdialog: ProgressDialog;

   private partkart: PartKart;

   public Main( )
   {
      // partkart related functions
      partkart = new PartKart( this );

      // setup stage scale mode and alignment
      this.stage.align = StageAlign.TOP_LEFT;
      this.stage.scaleMode = StageScaleMode.NO_SCALE;

      this.stage.addEventListener( Event.RESIZE, stageResize );

      this.background = new PIXI.Sprite( );
      this.addChild( this.background );

      this.grid = new Grid( );
      this.addChild( this.grid );

      this.scene = SceneGraph.getInstance( );
      this.addChild( this.scene );

      // tools pallete on top
      this.addChild( this.tools );
      this.attachToolsListeners( );

      addEventListener( 'mousedown', this.mainMouseDown );
      addEventListener( 'mouseup', this.mainMouseUp );
      this.stage.addEventListener( Event.MOUSE_LEAVE, this.mainMouseLeave );

      this.stage.addEventListener( KeyboardEvent.KEY_DOWN, this.mainKeyDown );
      this.stage.addEventListener( KeyboardEvent.KEY_UP, this.mainKeyUp );

      this.stage.dispatchEvent( new Event( Event.RESIZE ) );

      this.scene.redraw( );
   }

   public stageResize( e:Event )
   {
      if ( this.stage.stageWidth > 400 )
      {
         this.tools.background.width = this.stage.stageWidth;
         this.tools.viewcuts.x = this.stage.stageWidth - 254;
         this.tools.snap.x = this.stage.stageWidth - 173;
         this.tools.unit.x = this.stage.stageWidth - 111;
         this.tools.zoomin.x = this.stage.stageWidth - 53;
         this.tools.zoomout.x = this.stage.stageWidth - 29;
      }

      // resize from bottom left corner
      Global.yorigin += this.stage.stageHeight - Global.docheight;

      Global.docwidth = this.stage.stageWidth;
      Global.docheight = this.stage.stageHeight;
      this.grid.clear( );
      this.grid.init( );

      // redraw scene
      this.scene.redraw( );
   }

   public mainMouseDown( e: PIXI.interaction.InteractionEvent ): void
   {
      // remove all selectareas
      if ( getChildByName( "selectarea" ) )
      {
         this.removeChild( getChildByName( "selectarea" ) );
      }

      if ( Global.tool != 99 )
      {
         this.scene.clearDots( );
         this.clearMenu( );
         this.tools.active = false;
         this.stage.focus = null;
      }

      if ( Global.space == true && Global.tool != 99 )  // tool 99 means "no tool"
      {
         this.mainStartDrag( e );
      }
      else
      {
         switch( Global.tool )
         {
            case 0:
               this.mainStartSelect( e );
               break;
            case 2:
               this.mainStartDrag( e );
               break;
            case 1:
               this.startSketch( e );
               break;
            case 4:
               this.startPen( e );
               break;
         }
      }
   }

   /*public mainMiddleDown( e: PIXI.interaction.InteractionEvent ): void{
      mainStartDrag( e);
   }*/

   public mainStartDrag( e:  PIXI.interaction.InteractionEvent ): void
   {
      this.addChild( this.tools );  // tools should be on top when dragging
      this.xstart = e.stageX;
      this.ystart = e.stageY;
      this.xoriginstart = Global.xorigin;
      this.yoriginstart = Global.yorigin;
      this.dragging = true;
      Global.dragging = true;

      addEventListener( 'mousemove', this.mainDrag );
   }

   public mainDrag( e: PIXI.interaction.InteractionEvent ): void
   {
      if ( this.dragging && ( Global.tool == 2 || Global.space == true ) && Global.tool != 99 )
      {
         let xdelta: number = e.stageX - this.xstart;
         let ydelta: number = e.stageY - this.ystart;

         Global.xorigin = this.xoriginstart + xdelta;
         Global.yorigin = this.yoriginstart + ydelta;
         this.rid.setOrigin( );
         this.edrawBackground( );

         // update path positions
         this.cene.x = Global.xorigin;
         this.cene.y = Global.yorigin;
      }
      else if ( dragging && Global.tool == 0 )
      {
         let selectbox: PIXI.Sprite = this.etChildByName( "selectarea" ) as PIXI.Sprite;

         if ( selectbox != null )
         {
            let b: PIXI.Shape = selectbox.getChildAt( 0 )  as PIXI.Shape;

            let xs: number;
            let ys: number;

            let w: number;
            let h: number;

            if ( e.stageX > xstart )
            {
               xs = 0;
               w = e.stageX - xstart;
            }
            else
            {
               xs = e.stageX - xstart;
               w = xstart - e.stageX;
            }

            if ( e.stageY > ystart )
            {
               ys = 0;
               h = e.stageY - ystart;
            }
            else
            {
               ys = e.stageY - ystart;
               h = ystart - e.stageY;
            }

            b.x = xs;
            b.y = ys;
            b.width = w;
            b.height = h;
         }
      }
   }

   public mainMouseUp( e: PIXI.interaction.InteractionEvent ): void
   {
      removeEventListener( 'mousemove', this.mainDrag );
      if ( Global.dragging && Global.tool == 0 && !Global.space )
      {
         this.mainFinishSelect( );
      }
      this.dragging = false;
      Global.dragging = false;
   }

   public mainStartSelect( e: PIXI.interaction.InteractionEvent ): void
   {
      this.addChild( this.tools ); // tools should be on top when dragging
      this.xstart = e.stageX;
      this.ystart = e.stageY;

      this.dragging = true;
      Global.dragging = true;

      addEventListener( 'mousemove', this.mainDrag );

      let selectbox: PIXI.Sprite = new PIXI.Sprite( );
      this.selectbox.name = "selectarea";

      this.selectbox.x = e.stageX;
      this.selectbox.y = e.stageY;

      let box: PIXI.Shape = new PIXI.Shape( );
      box.graphics.beginFill( 0xbce4fe );
      box.graphics.drawRect( 0, 0, 1, 1 );
      box.graphics.endFill( );

      box.alpha = 0.5;

      this.selectbox.addChild( box );
      this.addChild( this.selectbox );

      this.scene.cacheAsBitmap = false;

      // disable all path related events until selection is finished
      this.scene.mouseChildren = false;
   }

   public mainFinishSelect( ): void
   {
      if ( !this.scene.ctrl )
      {
         this.scene.setInactive( );
      }

      let selectbox: PIXI.Sprite = getChildByName( "selectarea" ) as PIXI.Sprite;
      if ( selectbox != null && selectbox.width > 1 && selectbox.height > 1 )
      {
         this.scene.addChild( selectbox );
         selectbox.x -= this.scene.x;
         selectbox.y -= this.scene.y;

         this.scene.select( selectbox);
         this.scene.removeChild( selectbox );
      }
      this.scene.cacheAsBitmap = true;
      this.scene.mouseChildren = true;
   }

   public mainMouseLeave( e:Event ): void
   {
      // this function is required to handle cases where the mouse leaves the stage
      if ( this.dragging == true )
      {
         this.dragging = false;
         Global.dragging = false;
         removeEventListener( 'mousemove', this.mainDrag );
         this.mainFinishSelect( );
      }

      this.scene.mouseLeave( );
   }

   public mainKeyDown( e: KeyboardEvent ): void
   {
      if (  e.ctrlKey || e.shiftKey)
      {
         scene.ctrl = true;
      }
      else if ( e.keyCode == 32 && Global.space == false )  // space key
      {
         Global.space = true;
         Mouse.cursor = MouseCursor.HAND;
         scene.clearDots( );
         //scene.redraw( );
      }
      else if ( e.keyCode == 46 || e.keyCode == 8 )         // delete key
      {
         if ( stage.focus == null)
         {
            this.scene.deleteSelected( );
         }
      }
   }

   public mainKeyUp( e: KeyboardEvent ): void
   {
      if ( e.ctrlKey == true && e.keyCode == 67 )
      {
         this.scene.startCopy( );
      }
      else if ( e.ctrlKey == true && e.keyCode == 86 )
      {
         let p:Point = new Point( ( this.mouseX - Global.xorigin)/Global.zoom, ( -this.mouseY + Global.yorigin)/Global.zoom );
         trace( "paste point: ", p );
         this.scene.startPaste( p );
      }

      if ( !e.ctrlKey || !e.shiftKey )
      {
         this.scene.ctrl = false;
      }
      if (  e.keyCode == 32)
      {
         Global.space = false;
         this.setCursor( );
      }
   }

   public attachToolsListeners( ): void
   {
      this.tools.addEventListener( 'mouseover', this.toolsOver );
      this.tools.addEventListener( 'mousedown', this.toolsDown );
      this.tools.addEventListener( 'mousemove', this.toolsMove );
      this.tools.addEventListener( 'mouseup', this.toolsUp );
      //O this.tools.addEventListener( MouseEvent.MOUSE_OUT, this.toolsOut );
      this.tools.addEventListener( 'mouseout', this.toolsOut );

      //O this.tools.tool0.addEventListener( MouseEvent.MOUSE_OVER, this.toolOver );
      this.tools.tool0.addEventListener( 'mouseover', this.toolOver );
      this.tools.tool1.addEventListener( 'mouseover', this.toolOver );
      this.tools.tool2.addEventListener( 'mouseover', this.toolOver );
      this.tools.tool3.addEventListener( 'mouseover', this.toolOver );
      this.tools.tool4.addEventListener( 'mouseover', this.toolOver );

      this.tools.tool0.addEventListener( 'mousedown', this.toolDown );
      this.tools.tool1.addEventListener( 'mousedown', this.toolDown );
      this.tools.tool2.addEventListener( 'mousedown', this.toolDown );
      this.tools.tool3.addEventListener( 'mousedown', this.toolDown );
      this.tools.tool4.addEventListener( 'mousedown', this.toolDown );

      //O this.tools.tool0.addEventListener( MouseEvent.MOUSE_OUT, this.toolOut );
      this.tools.tool0.addEventListener( 'mouseout', this.toolOut );
      this.tools.tool1.addEventListener( 'mouseout', this.toolOut );
      this.tools.tool2.addEventListener( 'mouseout', this.toolOut);
      this.tools.tool3.addEventListener( 'mouseout', this.toolOut );
      this.tools.tool4.addEventListener( 'mouseout', this.toolOut );

      //O this.tools.zoomin.addEventListener( MouseEvent.CLICK, this.zoomIn );
      this.tools.zoomin.addEventListener( 'click', this.zoomIn );
      //O this.tools.zoomout.addEventListener( MouseEvent.CLICK, this.zoomOut );
      this.tools.zoomout.addEventListener( 'click', this.zoomOut );

      //O this.stage.addEventListener( MouseEvent.MOUSE_WHEEL, this.zoomWheel );
      this.stage.addEventListener( 'wheel', this.zoomWheel );

      //O this.tools.unit.addEventListener( Event.CHANGE, this.unitChange );

      //O this.tools.snap.addEventListener( Event.CHANGE, this.snapChange );
      //O this.tools.viewcuts.addEventListener( Event.CHANGE, this.viewcutsChange );

      this.tools.active = false;

      this.tools.mFile.mouseChildren = false;
      this.tools.mEdit.mouseChildren = false;
      this.tools.mInsert.mouseChildren = false;
      this.tools.mCAM.mouseChildren = false;
      this.tools.mToolpaths.mouseChildren = false;
      this.tools.mNesting.mouseChildren = false;
      this.tools.mPartkart.mouseChildren = false;

      this.tools.dFile.visible = false;
      this.tools.dEdit.visible = false;
      this.tools.dInsert.visible = false;
      this.tools.dCAM.visible = false;
      this.tools.dToolpaths.visible = false;
      this.tools.dNesting.visible = false;
      this.tools.dPartkart.visible = false;

      //O this.tools.dFile.addEventListener( Event.CHANGE, this.menuSelect );
      //O this.tools.dEdit.addEventListener( Event.CHANGE, this.menuSelect );
      //O this.tools.dInsert.addEventListener( Event.CHANGE, this.menuSelect );
      //O this.tools.dCAM.addEventListener( Event.CHANGE, this.menuSelect );
      //O this.tools.dToolpaths.addEventListener( Event.CHANGE, this.menuSelect );
      //O this.tools.dNesting.addEventListener( Event.CHANGE, this.menuSelect );
      //O this.tools.dPartkart.addEventListener( Event.CHANGE, this.menuSelect );
      //o this.tools.dToolpaths.addEventListener( ListEvent.ITEM_ROLL_OVER, this.toolpathOver );

      this.tools.mFile.drop = this.tools.dFile;
      this.tools.mEdit.drop = this.tools.dEdit;
      this.tools.mInsert.drop = this.tools.dInsert;
      this.tools.mCAM.drop = this.tools.dCAM;
      this.tools.mToolpaths.drop = this.tools.dToolpaths;
      this.tools.mNesting.drop = this.tools.dNesting;
      this.tools.mPartkart.drop = this.tools.dPartkart;

      //O this.tools.mFile.addEventListener( MouseEvent.ROLL_OVER, this.menuOver );
      //O this.tools.mEdit.addEventListener( MouseEvent.ROLL_OVER, this.menuOver );
      //O this.tools.mInsert.addEventListener( MouseEvent.ROLL_OVER, this.menuOver );
      //O this.tools.mCAM.addEventListener( MouseEvent.ROLL_OVER, this.menuOver );
      //O this.tools.mToolpaths.addEventListener( MouseEvent.ROLL_OVER, this.menuOver );
      //O this.tools.mNesting.addEventListener( MouseEvent.ROLL_OVER, this.menuOver );
      //O this.tools.mPartkart.addEventListener( MouseEvent.ROLL_OVER, this.menuOver );

      //O this.tools.mFile.addEventListener( MouseEvent.ROLL_OUT, this.menuOut );
      this.tools.mFile.addEventListener( 'mouseupoutside', this.menuOut );
      this.tools.mEdit.addEventListener( 'mouseupoutside', this.menuOut );
      this.tools.mInsert.addEventListener( 'mouseupoutside', this.menuOut );
      this.tools.mCAM.addEventListener( 'mouseupoutside', this.menuOut );
      this.tools.mToolpaths.addEventListener( 'mouseupoutside', this.menuOut );
      this.tools.mNesting.addEventListener( 'mouseupoutside', this.menuOut );
      this.tools.mPartkart.addEventListener( 'mouseupoutside', this.menuOut );

      //Othis.tools.mFile.addEventListener( MouseEvent.MOUSE_DOWN, this.menuDown );
      this.tools.mFile.addEventListener( 'mousedown', this.menuDown );
      this.tools.mEdit.addEventListener( 'mousedown', this.menuDown );
      this.tools.mInsert.addEventListener( 'mousedown', this.menuDown );
      this.tools.mCAM.addEventListener( 'mousedown', this.menuDown );
      this.tools.mToolpaths.addEventListener( 'mousedown', this.menuDown );
      this.tools.mNesting.addEventListener( 'mousedown', this.menuDown );
      this.tools.mPartkart.addEventListener( 'mousedown', this.menuDown );
   }

   public clearMenu(  ): void
   {
      this.tools.mFile.highlightDown.alpha = 0;
      this.tools.mEdit.highlightDown.alpha = 0;
      this.tools.mInsert.highlightDown.alpha = 0;
      this.tools.mCAM.highlightDown.alpha = 0;
      this.tools.mToolpaths.highlightDown.alpha = 0;
      this.tools.mNesting.highlightDown.alpha = 0;
      this.tools.mPartkart.highlightDown.alpha = 0;

      this.tools.mFile.highlightUp.alpha = 0;
      this.tools.mEdit.highlightUp.alpha = 0;
      this.tools.mInsert.highlightUp.alpha = 0;
      this.tools.mCAM.highlightUp.alpha = 0;
      this.tools.mToolpaths.highlightUp.alpha = 0;
      this.tools.mNesting.highlightUp.alpha = 0;
      this.tools.mPartkart.highlightUp.alpha = 0;

      this.tools.mFile.text.textColor =  0x000000;
      this.tools.mEdit.text.textColor =  0x000000;
      this.tools.mInsert.text.textColor =  0x000000;
      this.tools.mCAM.text.textColor =  0x000000;
      this.tools.mToolpaths.text.textColor =  0x000000;
      this.tools.mNesting.text.textColor =  0x000000;
      this.tools.mPartkart.text.textColor =  0x000000;

      this.tools.dFile.visible = false;
      this.tools.dEdit.visible = false;
      this.tools.dInsert.visible = false;
      this.tools.dCAM.visible = false;
      this.tools.dToolpaths.visible = false;
      this.tools.dNesting.visible = false;
      this.tools.dPartkart.visible = false;

      this.tools.dFile.clearSelection( );
      this.tools.dEdit.clearSelection( );
      this.tools.dInsert.clearSelection( );
      this.tools.dCAM.clearSelection( );
      this.tools.dToolpaths.clearSelection( );
      this.tools.dNesting.clearSelection( );
      this.tools.dPartkart.clearSelection( );
   }

   public toolsOver( e: PIXI.interaction.InteractionEvent ): void
   {
      Mouse.cursor = MouseCursor.AUTO;
   }

   public toolsDown( e: PIXI.interaction.InteractionEvent ): void
   {
      e.stopPropagation( );
      this.addChild( this.tools ); // put on top of z stack
   }

   public toolsMove( e: PIXI.interaction.InteractionEvent ): void
   {
      e.stopPropagation( );
   }

   public toolsUp( e: PIXI.interaction.InteractionEvent ): void
   {
      //e.stopPropagation( );
   }

   public toolsOut( e: PIXI.interaction.InteractionEvent ): void
   {
      this.setCursor( );
   }

   public toolOver( e: PIXI.interaction.InteractionEvent ): void
   {
      e.target.alpha = 0.5;
   }

   public toolDown( e: PIXI.interaction.InteractionEvent ): void
   {
      e.target.alpha = 1;

      if ( Global.tool == 4 && e.target.name != "tool4" )
      {
         // clean up pen operations
         if ( pen != null)
         {
            this.pen.graphics.clear( );
            this.pen = null;
            removeEventListener( 'mousemove', this.movePen );
            removeEventListener( 'mouseup', this.upPen );
         }
      }

      if ( e.target.name == "tool0")
      {
         Global.tool = 0;
         this.scene.clearDots( );
         this.setZoom( Global.zoom );  // re-render everything
      }
      else if ( e.target.name == "tool1" )
      {
         Global.tool = 1;
         this.scene.addDots( );
         this.setZoom( Global.zoom );  // re-render everything
      }
      else if ( e.target.name == "tool2" )
      {
         Global.tool = 2;
         this.scene.clearDots( );
         this.setZoom( Global.zoom );  // re-render everything
      }
      else if ( e.target.name == "tool3" )
      {
         Global.tool = 3;
         this.scene.addDots( );
         this.setZoom( Global.zoom );   // re-render everything
      }
      else if ( e.target.name == "tool4" )
      {
         Global.tool = 4;
         this.scene.clearDots( );
         this.setZoom( Global.zoom );  // re-render everything
      }

      this.setCursor( );
   }

   public toolOut( e: PIXI.interaction.InteractionEvent ): void
   {
      e.target.alpha = 1;
   }

   public menuOver( e: PIXI.interaction.InteractionEvent ): void
   {
      if ( this.tools.active == false )
      {
         e.target.getChildByName( "highlightUp").alpha = 0.15;
      }
      else if ( e.target )
      {
         this.clearMenu( );
         e.target.getChildByName( "highlightDown" ).alpha = 1;
         let t:TextField = e.target.getChildByName( "text" ) as TextField;
         t.textColor = 0xffffff;
         if ( e.target.drop )
         {
            e.target.drop.visible = true;
         }
      }
   }

   public menuOut( e: PIXI.interaction.InteractionEvent ): void
   {
      if ( this.tools.active == false)
      {
         e.target.getChildByName( "highlightUp" ).alpha = 0;
         let t:TextField = e.target.getChildByName( "text" ) as TextField;
         t.textColor = 0x000000;
      }
   }

   public toolpathOver( e:ListEvent ): void
   {
      for each( let cut:CutObject in this.scene.cutlist )
      {
         cut.setInactive( );
      }
      e.item.data.setActive( );
      this.stage.focus = null;
   }

   public menuDown( e: PIXI.interaction.InteractionEvent ): void
   {
      let t:TextField = e.target.getChildByName( "text" ) as TextField;

      if ( this.tools.active == true )
      {
         this.tools.active = false;
         this.clearMenu( );
      }
      else
      {
         this.tools.active = true;

         this.clearMenu( );

         e.target.getChildByName( "highlightDown" ).alpha = 1;
         if ( e.target.drop )
         {
            e.target.drop.visible = true;
         }

         t.textColor = 0xffffff;
      }
   }

   public menuSelect( e:Event ): void
   {
      if ( e.target == tools.dFile )
      {
         switch( e.target.selectedIndex )
         {
            case 0:
               // import file
               trace( "import!");
               this.loadFile( );
               break;
            case 1:
               // export file
               trace( "export!" );
               this.saveFile( );
               break;
         }
      }
      else if ( e.target == tools.dEdit )
      {
         switch( e.target.selectedIndex )
         {
            case 0:
               // undo
               Global.undoAction( );
               this.scene.redraw( );
               break;
            case 1:
               // redo
               Global.redoAction( );
               this.scene.redraw( );
               break;
            case 2:
               // copy
               this.scene.startCopy( );
               break;
            case 3:
               // paste
               this.scene.startPaste( );
               break;
            case 4:
               this.startDialog( 120, 100, new Array( {type: "number", label:"Scale X ( %)", value: 100},
                  {type: "number", label:"Scale Y ( %)", value: 100}
               ),
                  "scale" );
               break;
            case 5:
               this.startDialog( 120, 50, new Array( {type: "number", label:"Rotate ( degrees)", value: "0" }
               ),
                  "rotate" );
               break;
            case 6:
               this.startDialog( 120, 100, new Array( {type: "number", label:"Skew X ( %)", value: "0"},
                  { type: "number", label:"Skew Y ( %)", value: "0" }
               ),
                  "skew" );
               break;
            case 7:
               this.scene.separateSelected( );
               break;
            case 8:
               this.startDialog( 200, 100, new Array( {type: "file", label:"Load Image From Disk"},
                  {type:"number", label: "Image Resolution ( px/" + Global.unit + ")", value: backgroundscale},
                  {type:"number", label:"Visibility ( %)", value: String( backgroundvisibility )}
               ),
                  "background" );
               break;
            case 9:
               this.startDialog( 250, 150, new Array( {type: "number", label:"SVG Import Default Resolution ( px/inch)", value:Global.importres },
                  {type:"label", label:"Common values:" },
                  {type:"label", label:"Illustrator: 72, Inkscape: 90" },
                  {type:"label", label:""},
                  {type:"checkbox", label:"Snap to local points", value:Global.localsnap},
                  {type:"label", label:"" },
                  {type: "number", label: "Output Precision ( numbers after decimal)", value: Global.precision},
                  {type: "number", label: "Machining Tolerance ( "+Global.unit+")", value: Global.tolerance},
                  {type: "number", label: "Bitmap Tolerance", value: Global.bitmaptolerance},
                  {type: "number", label: "Nesting Bitmap Size", value: Global.nestbitmapsize},
                  {type: "checkbox", label: "Separate Toolpaths by Boundary", value: Global.separatetoolpaths }
               ),
                  "preferences" );
               break;
         }
      }
      else if ( e.target == tools.dInsert )
      {
         switch( e.target.selectedIndex )
         {
            case 0:
               // add circle
               this.startDialog( 120, 50, new Array( {type:"number", label:"Diameter ( "+Global.unit+")", value:1}
               ),
                  "addcircle" );
               break;
            case 1:
               // add ellipse
               this.startDialog( 120, 100, new Array( 
                  {type:"number", label:"Ellipse Width ( " + Global.unit + ")", value:1},
                  {type:"number", label:"Ellipse Height ( " + Global.unit + ")", value:1}
               ),
                  "addellipse" );
               break;
            case 2:
               // add rectangle
               startDialog( 150, 100, new Array( {type:"number", label:"Rectangle Width ( "+Global.unit+")", value:1},
                  {type:"number", label:"Rectangle Height ( " + Global.unit + ")", value:1}
               ),
                  "addrectangle" );
               break;
            case 3:
               // add rounded rectangle
               startDialog( 150, 100, new Array( {type:"number", label:"Rectangle Width ( "+Global.unit+")", value:1},
                  {type:"number", label:"Rectangle Height ( " + Global.unit + ")", value:1},
                  {type:"number", label:"Corner Radius ( " + Global.unit + ")", value:0.2}
               ),
                  "addroundedrectangle" );
               break;
            case 4:
               // add polygon
               startDialog( 120, 100, new Array( {type:"number", label:"Number of Sides", value:6},
                  {type:"number", label:"Radius ( " + Global.unit + ")", value:1}
               ),
                  "addpolygon" );
               break;
            case 5:
               // add star
               this.startDialog( 120, 100, new Array( {type:"number", label:"Number of Points", value:6},
                  {type:"number", label:"Radius ( " + Global.unit + ")", value:1},
                  {type:"number", label:"Pointiness ( %)", value:50}
               ),
                  "addstar" );
               break;
         }
      }
      else if ( e.target == tools.dCAM )
      {
         let selected: boolean;
         let p:Path;
         let closed: boolean;
         let unit: string;

         // setup default values to populate fields

         let safetyheight: number = Global.unit == "in" ? 0.125 : 15;
         let stocksurface: string = "0";
         let targetdepth: number  = Global.unit == "in" ? -0.76 : -10;
         let stepdown: number = Global.unit == "in" ? 0.03125 : 1.5;
         let stepover: number = 40;
         let feedrate: number = Global.unit == "in" ? 30 : 1500;
         let plungerate: number = Global.unit == "in" ? 10 : 800;

         let tooldiameter: number = Global.unit == "in" ? 0.125 : 5;
         let roughingclearance: string = "0";
         let dir:int = 1;

         switch( e.target.selectedIndex )
         {
            case 0:
               // make sure at least one path is selected
               selected = false;
               for each( p in this.scene.pathlist )
               {
                  closed = p.isClosed( );
                  if ( p.active == true && closed )
                  {
                     selected = true;
                  }
                  else if ( p.active == true && !closed )
                  {
                     p.setInactive( );
                  }
               }

               if ( selected == false )
               {
                  this.startDialog( 240, 50, new Array( {type:"label", label:"Please select at least one closed path"}
                  ), "error" );
               }
               else
               {

                  unit = Global.unit == "in" ? "in" : "mm";

                  this.startDialog( 150,200, new Array( {type:"string", label:"name", value:"profile "+( scene.cutlist.length + 1 )},
                     {type:"number", label:"tool diameter ( " + unit + ")", value: tooldiameter, highlight: true},
                     {type:"number", label:"target depth ( " + unit + ")", value: targetdepth, highlight: true},
                  {
                     type:"combobox", label:"inside/outside", items:new Array( 
                     {
                        label:"Outside", data:true
                     }
                     ,
                     {
                        label:"Inside", data:false
                     }
                     )
                  },
                     {type:"number", label:"safety height ( " + unit + ")", value:safetyheight},
                     {type:"number", label:"stock surface ( " + unit + ")", value: stocksurface},
                     {type:"number", label:"step down ( " + unit + ")", value: stepdown},
                     {type:"number", label:"feed rate ( " + unit + "/minute)", value: feedrate},
                     {type:"number", label:"plunge rate ( " + unit + "/minute)", value: plungerate},
                  {
                     type:"combobox", label:"direction", items:new Array( 
                     {
                        label:"Counter Clockwise", data:1
                     }
                     ,
                     {
                        label:"Clockwise", data:2
                     }
                     )
                  }
                  ),
                     "profile");
               }
               break;
            case 1:
               // make sure at least one path is selected
               selected = false;
               for each( p in scene.pathlist )
               {
                  closed = p.isClosed( );
                  if ( p.active == true && closed )
                  {
                     selected = true;
                  }
                  else if ( p.active == true && !closed )
                  {
                     p.setInactive( );
                  }
               }

               if ( selected == false )
               {
                  this.startDialog( 240, 50, new Array( {type:"label", label:"Please select at least one closed path"}
                  ), "error" );
               }
               else
               {

                  unit = Global.unit == "in" ? "in" : "mm";

                  this.startDialog( 150,200, new Array( {type:"string", label:"name", value:"pocket "+( scene.cutlist.length+1)},
                     {type:"number", label:"tool diameter ( " + unit + ")", value: tooldiameter, highlight: true},
                     {type:"number", label:"target depth ( " + unit + ")", value: targetdepth, highlight: true},
                     {type:"number", label:"safety height ( " + unit + ")", value: safetyheight},
                     {type:"number", label:"stock surface ( " + unit + ")", value: stocksurface},
                     {type:"number", label:"step over ( %)", value: stepover},
                     {type:"number", label:"step down ( " + unit + ")", value: stepdown},
                     {type:"number", label:"roughing clearance ( "+unit+")", value: roughingclearance},
                     {type:"number", label:"feedrate ( " + unit + "/minute)", value: feedrate},
                     {type:"number", label:"plunge rate ( " + unit + "/minute)", value: plungerate},
                  {
                     type:"combobox", label:"direction", items:new Array( 
                     {
                        label:"Counter Clockwise", data:1
                     }
                     ,
                     {
                        label:"Clockwise", data:2
                     }
                     )
                  }
                  ),
                     "pocket" );
               }
               break;
            case 2:
               selected = false;
               for each( p in scene.pathlist )
               {
                  if ( p.active == true )
                  {
                     selected = true;
                  }
               }

               if ( selected == false )
               {
                  this.startDialog( 230, 50, new Array( {type:"label", label:"Please select at least one path"}
                  ), "error" );
               }
               else
               {

                  this.unit = Global.unit == "in" ? "in" : "mm";

                  this.startDialog( 150,200, new Array( {type:"string", label:"name", value:"follow path " + ( this.scene.cutlist.length + 1 ) },
                     {type:"number", label:"tool diameter ( " + unit + ")", value: tooldiameter, highlight: true},
                     {type:"number", label:"target depth ( " + unit + ")", value: targetdepth, highlight: true},
                     {type:"number", label:"safety height ( " + unit + ")", value: safetyheight},
                     {type:"number", label:"stock surface ( " + unit + ")", value: stocksurface},
                     {type:"number", label:"step down ( " + unit + ")", value: stepdown},
                     {type:"number", label:"feedrate ( " + unit + "/minute)", value: feedrate},
                     {type:"number", label:"plunge rate ( " + unit + "/minute)", value: plungerate}
                  ),
                     "followpath");
               }
               break;
            case 3:
               // drill operation
               unit = Global.unit == "in" ? "in" : "mm";

               this.startDialog( 150,200, new Array( {type:"string", label:"name", value:"drill "i +i ( this.scene.cutlist.length+1)},
                  {type:"number", label:"tool diameter ( " + unit + ")", value: tooldiameter, highlight: true},
                  {type:"number", label:"target depth ( " + unit + ")", value: targetdepth, highlight: true},
               {
                  type:"combobox", label:"drill location", items:new Array(
                  {
                     label:"path center", data:true
                  }
                  ,
                  {
                     label:"fill pattern", data:false
                  }
                  ), value: true, highlight: true
               },
                  {type:"number", label:"hole spacing ( " + unit + ")", value: tooldiameter*2, highlight: true},
                  {type:"number", label:"safety height ( " + unit + ")", value: safetyheight},
                  {type:"number", label:"stock surface ( " + unit + ")", value: stocksurface},
                  {type:"number", label:"peck distance ( " + unit + ")", value: stepdown},
                  {type:"number", label:"plunge rate ( " + unit + "/minute)", value: plungerate}
               ),
                  "drill" );
               break;
            case 4:
               // add tabs

               // check that there is at least one calculated profile op
               let valid: boolean = false;
               for each( let cutobject:CutObject in scene.cutlist )
               {
                  if (  cutobject is ProfileCutObject && cutobject.processed == true)
                  {
                     valid = true;
                     break;
                  }
               }

               if ( !valid )
               {
                  this.startDialog( 320,50,new Array( {type:"label", label:"Please select at least one calculated profile operation"}
                  ), "error" );
                  return;
               }

               this.startDialog( 150,200, new Array( {type:"number", label:"tab spacing ( "+Global.unit+")", value: Global.unit == "in" ? 5 : 15},
                  {type:"number", label:"tab width ( " + Global.unit + ")", value: Global.unit == "in" ? .25 : 0.5},
                  {type:"number", label:"tab height ( " + Global.unit + ")", value: Global.unit == "in" ? .25 : 0.5}
               ),
                  "tabs" );
               break;
            case 5:
               let pd:ProgressDialog = startProgressDialog( 250, 75, "processing", "Cancel", scene.cutCancel);
               scene.reprocessCuts( pd );
               break;
            case 6:
               let pd1:ProgressDialog = startProgressDialog( 250, 75, "processing", "Cancel", scene.cutCancel);
               this.scene.reprocessCuts( pd1, true );
               break;
            case 7:
               this.unit = Global.unit == "in" ? "in" : "mm";

               // get defaults based on selected
               let activecuts:Array = this.scene.getActiveCuts( );

               let this.center: boolean = true;
               let this.spacing: number = tooldiameter*2;
               let this.outside: boolean = true;

               //O for each( let cut:CutObject in activecuts)
               for ( let cut:CutObject in this.activecuts)
               {
                  if ( !isNaN( cut.tooldiameter))
                  {
                     this.tooldiameter = cut.tooldiameter;
                  }
                  if ( !isNaN( cut.targetdepth ) )
                  {
                     this.targetdepth = cut.targetdepth;
                  }
                  outside = cut.outside;
                  if ( !isNaN( cut.safetyheight ) )
                  {
                     this.safetyheight = cut.safetyheight;
                  }
                  if ( !isNaN( cut.stocksurface ) )
                  {
                     this.stocksurface = String( cut.stocksurface );
                  }
                  if ( !isNaN( cut.stepover ) )
                  {
                    this. stepover = cut.stepover;
                  }
                  if ( !isNaN( cut.stepdown ) )
                  {
                    this. stepdown = cut.stepdown;
                  }
                  if ( !isNaN( cut.roughingclearance ) )
                  {
                     this.roughingclearance = String( cut.roughingclearance );
                  }
                  if ( !isNaN( cut.feedrate ) )
                  {
                     this.feedrate = cut.feedrate;
                  }
                  if ( !isNaN( cut.plungerate ) )
                  {
                     this.plungerate = cut.plungerate;
                  }
                  if ( !isNaN( cut.dir ) )
                  {
                     this.dir = cut.dir;
                  }
                  center = cut.center;
                  if ( !isNaN( cut.spacing ) )
                  {
                     this.spacing = cut.spacing;
                  }
               }

               this.startDialog( 150,200, new Array(   {type:"number", label:"tool diameter ( "+unit+")", value: tooldiameter},
                  {type:"number", label:"target depth ( " + unit + ")", value: targetdepth},
               {
                  type:"combobox", label:"inside/outside", items:new Array( 
                  {
                     label:"Outside", data:true
                  }
                  ,
                  {
                     label:"Inside", data:false
                  }
                  ), value: outside
               },
                  {type:"number", label:"safety height ( " + unit + ")", value: safetyheight},
                  {type:"number", label:"stock surface ( " + unit + ")", value: stocksurface},
                  {type:"number", label:"step over ( %)", value: stepover},
                  {type:"number", label:"step down ( " + unit + ")", value: stepdown},
                  {type:"number", label:"roughing clearance ( " + unit + ")", value: roughingclearance},
                  {type:"number", label:"feedrate ( " + unit + "/minute)", value: feedrate},
                  {type:"number", label:"plunge rate ( " + unit + "/minute)", value: plungerate},
               {
                  type:"combobox", label:"direction", items:new Array( 
                  {
                     label:"Counter Clockwise", data:1
                  }
                  ,
                  {
                     label:"Clockwise", data:2
                  }
                  ),value: dir
               },
               {
                  type:"combobox", label:"drill location", items:new Array( 
                  {
                     label:"path center", data:true
                  }
                  ,
                  {
                     label:"fill pattern", data:false
                  }
                  ), value: center, highlight: true
               },
                  {type:"number", label:"hole spacing ( " + unit + ")", value: spacing}
               ),
                  "batch" );
               break;
            case 8:
               let processed:Array = this.scene.getProcessedCuts( );
               let fields:Array = new Array( );
               //O for each( cut in processed )
               for ( cut in this.processed )
               {
                  fields.push( {label: cut.name + " ( " + Global.toFixed( cut.tooldiameter, Global.precision ) + ")", data: cut, diameter: cut.tooldiameter, active: cut.active}
                  );
               }
               this.startDialog( 300,200, new Array( {type:"cutlist", label:"calculated toolpaths", value: fields},
               {
                  type:"combobox", label:false, items:new Array( 
                  {
                     label:"Standard G-Code", data:0
                  }
                  ), value: 0
               }),
                  "exportgcode", "Export Selected Toolpaths", false );
               break;
         }
      }
      else if ( e.target == tools.dToolpaths )
      {

         let selectedindex:int = tools.dToolpaths.selectedIndex;

         this.unit = Global.unit == "in" ? "in" : "mm";

         if ( e.target.selectedItem.data is ProfileCutObject )
         {
            let profile:ProfileCutObject = e.target.selectedItem.data as ProfileCutObject;
            this.startDialog( 150,200, new Array( {type:"string", label:"name", value: profile.name},
               {type:"number", label:"tool diameter ( " + unit + ")", value: unit == "mm" ? 10*profile.tooldiameter : profile.tooldiameter, highlight: true},
               {type:"number", label:"target depth ( " + unit + ")", value: profile.targetdepth == 0 ? String( profile.targetdepth ):  profile.targetdepth, highlight: true},
            {
               type:"combobox", label:"inside/outside", items:new Array( 
               {
                  label:"Outside", data:true
               }
               ,
               {
                  label:"Inside", data:false
               }
               ), value: profile.outside
            },
               {type:"number", label:"safety height ( " + unit + ")", value: profile.safetyheight == 0 ? String( profile.safetyheight) : profile.safetyheight},
               {type:"number", label:"stock surface ( " + unit + ")", value: profile.stocksurface == 0 ? String( profile.stocksurface ):  profile.stocksurface},
               {type:"number", label:"step down ( " + unit + ")", value: profile.stepdown},
               {type:"number", label:"feedrate ( " + unit + "/minute)", value: profile.feedrate},
               {type:"number", label:"plunge rate ( " + unit + "/minute)", value: profile.plungerate},
            {
               type:"combobox", label:"direction", items:new Array( 
               {
                  label:"Counter Clockwise", data:1
               }
               ,
               {
                  label:"Clockwise", data:2
               }
               ), value: profile.dir
            }
            ),
               "editprofile" );
         }
         else if ( e.target.selectedItem.data is PocketCutObject )
         {
            let pocket:PocketCutObject = e.target.selectedItem.data as PocketCutObject;
            this.startDialog( 150,200, new Array( {type:"string", label:"name", value: pocket.name},
               {type:"number", label:"tool diameter ( " + unit + ")", value: unit == "mm" ? 10*pocket.tooldiameter : pocket.tooldiameter, highlight: true},
               {type:"number", label:"target depth ( " + unit + ")", value: pocket.targetdepth == 0 ? String( pocket.targetdepth) : pocket.targetdepth, highlight: true},
               {type:"number", label:"safety height ( " + unit + ")", value: pocket.safetyheight == 0 ? String( pocket.safetyheight) : pocket.safetyheight},
               {type:"number", label:"stock surface ( " + unit + ")", value: pocket.stocksurface == 0 ? String( pocket.stocksurface) : pocket.stocksurface},
               {type:"number", label:"step over ( %)", value: 100*pocket.stepover},
               {type:"number", label:"step down ( " + unit + ")", value: pocket.stepdown},
               {type:"number", label:"roughing clearance ( " + unit + ")", value: pocket.roughingclearance == 0 ? "0" :( unit == "mm" ? 10*pocket.roughingclearance : pocket.roughingclearance)},
               {type:"number", label:"feedrate ( " + unit + "/minute)", value: pocket.feedrate},
               {type:"number", label:"plunge rate ( " + unit + "/minute)", value: pocket.plungerate},
            {
               type:"combobox", label:"direction", items:new Array( 
               {
                  label:"Counter Clockwise", data:1
               }
               ,
               {
                  label:"Clockwise", data:2
               }
               ), value: pocket.dir
            }),
               "editpocket" );
         }
         else if ( e.target.selectedItem.data is FollowPathCutObject )
         {
            let follow:FollowPathCutObject = e.target.selectedItem.data as FollowPathCutObject;
            this.startDialog( 150,200, new Array( {type:"string", label:"name", value: follow.name},
               {type:"number", label:"tool diameter ( " + unit + ")", value: unit == "mm" ? 10*follow.tooldiameter : follow.tooldiameter, highlight: true},
               {type:"number", label:"target depth ( " + unit + ")", value: follow.targetdepth == 0 ? String( follow.targetdepth) : follow.targetdepth, highlight: true},
               {type:"number", label:"safety height ( " + unit + ")", value: follow.safetyheight == 0 ? String( follow.safetyheight) : follow.safetyheight},
               {type:"number", label:"stock surface ( " + unit + ")", value: follow.stocksurface == 0 ? String( follow.stocksurface) : follow.stocksurface},
               {type:"number", label:"step down ( " + unit + ")", value: follow.stepdown},
               {type:"number", label:"feedrate ( " + unit + "/minute)", value: follow.feedrate},
               {type:"number", label:"plunge rate ( " + unit + "/minute)", value: follow.plungerate}
            ),
               "editfollowpath" );
         }
         else if ( e.target.selectedItem.data is DrillCutObject )
         {
            let drill:DrillCutObject = e.target.selectedItem.data as DrillCutObject;
            this.startDialog( 150,200, new Array( {type:"string", label:"name", value: drill.name},
               {type:"number", label:"tool diameter ( " + unit + ")", value: unit == "mm" ? 10*drill.tooldiameter : drill.tooldiameter, highlight: true},
               {type:"number", label:"target depth ( " + unit + ")", value: drill.targetdepth == 0 ? String( drill.targetdepth ) : drill.targetdepth, highlight: true},
            {
               type:"combobox", label:"drill location", items:new Array( 
               {
                  label:"path center", data:true
               }
               ,
               {
                  label:"fill pattern", data:false
               }
               ), value: drill.center, highlight: true
            },
               {type:"number", label:"hole spacing ( " + unit + ")", value: unit == "mm" ? 10*drill.spacing : drill.spacing, highlight: true},
               {type:"number", label:"safety height ( " + unit + ")", value: drill.safetyheight == 0 ? String( drill.safetyheight) : drill.safetyheight},
               {type:"number", label:"stock surface ( " + unit + ")", value: drill.stocksurface == 0 ? String( drill.stocksurface) : drill.stocksurface},
               {type:"number", label:"peck distance ( " + unit + ")", value: drill.stepdown},
               {type:"number", label:"plunge rate ( " + unit + "/minute)", value: drill.plungerate}
            ),
               "editdrill" );
         }
      }
      else if ( e.target == this.tools.dNesting )
      {
         switch( e.target.selectedIndex )
         {
            case 0:
               let selectedpaths:Array = new Array( );
               //O for each( let path:Path in this.scene.pathlist)
               for ( let path:Path in this.scene.pathlist )
               {
                  if ( path.active == true )
                  {
                     this.selectedpaths.push( path );
                  }
               }

               if ( this.selectedpaths.length != 1 )
               {
                  this.startDialog( 375,50,new Array( {type:"label", label:"Please specify exactly one closed path to act as the material boundary"}
                  ), "error" );
               }
               else if ( !this.selectedpaths[0].isClosed( ) )
               {
                  this.startDialog( 230,50,new Array( {type:"label", label:"The selected path is not a closed path"}
                  ), "error" );
               }
               else
               {
                  this.scene.nestpath = this.selectedpaths[ 0 ];
               }
               break;
            case 1:
               if ( scene.nestpath == null || !this.scene.contains( this.scene.nestpath ))
               {
                  this.startDialog( 330,50,new Array( {type:"label", label:"Please specify a closed path to act as the material boundary"}
                  ), "error" );
               }
               else
               {
                  this.startDialog( 200, 100, new Array( {type:"number", label:"angles", value: 4},
                     {type:"number", label:"space between objects ( " + Global.unit + ")", value: '0'},
                     {type:"checkbox", label:"group overlapping toolpaths", value: true},
                     {type:"checkbox", label:"group profile operations", value: false}
                  ),
                     "startnest" );
               }
               break;
         }
      }
      else if ( e.target == tools.dPartkart )
      {
         switch( e.target.selectedIndex )
         {
            case 0:
               this.partkart.order( this.scene.getActiveCuts( ) );
               break;
            case 1:
               this.partkart.order( this.scene.cutlist.slice( ) );
               break;
         }

         this.scene.redraw( );
      }

      this.clearMenu( );
      this.tools.active = false;

      // select the item in the toolpath menu for further processing
      if ( e.target == this.tools.dToolpaths )
      {
         this.tools.dToolpaths.selectedIndex = selectedindex;
      }
   }

   public setCursor(  ): void
   {
      if ( Global.tool == 0 || Global.tool == 3 || Global.tool == 4 )
      {
         this.Mouse.cursor = MouseCursor.AUTO;
      }
      else if ( Global.tool == 1 )
      {
         this.Mouse.cursor = MouseCursor.BUTTON;
      }
      else if ( Global.tool == 2 )
      {
         this.Mouse.cursor = MouseCursor.HAND;
      }
   }

   public zoomIn( e: PIXI.interaction.InteractionEvent ): void
   {
      if ( Global.zoom < 200)
      {
         this.setZoom( Global.zoom*1.2);
      }
   }

   public zoomOut( e: PIXI.interaction.InteractionEvent ): void
   {
      if ( Global.zoom > 15 )
      {
         this.setZoom( Global.zoom * 0.8 );
      }
   }

   public zoomWheel( e: PIXI.interaction.InteractionEvent ): void
   {
      if ( Global.dragging == false && Global.tool != 99 )
      {

         if ( this.zooming == false )
         {
            this.zooming = true;
            //stage.quality = StageQuality.LOW;
            //scene.cacheAsBitmap = false;
            this.startzoom = Global.zoom;
            this.timer = new Timer( 100, 1 );
            this.timer.addEventListener( TimerEvent.TIMER_COMPLETE, finishZoom );
            this.timer.start( );
         }
         else
         {
            if ( this.timer )
            {
               this.timer.reset( );
               this.timer.start( );
            }
         }

         let d:int = e.delta/Math.abs( e.delta );
         if (  d < 0)
         {
            if ( Global.zoom < 2000)
            {
               this.imposterZoom( Global.zoom*1.2, new Point( e.stageX, e.stageY ) );
               //setZoom( Global.zoom*1.2, new Point( e.stageX, e.stageY ) );
            }
         }
         else if ( d > 0)
         {
            this.imposterZoom( Global.zoom * 0.8 );
            //zoomOut( e); // zoom in on mouse but zoom out on center, this is also a method of navigation
         }
      }
   }

   public finishZoom( e:TimerEvent ): void
   {
      this.zooming = false;
      //stage.quality = StageQuality.HIGH;
      //scene.cacheAsBitmap = true;
      if ( this.imposter != null && contains( this.imposter ) )
      {
         this.removeChild( this.imposter );
      }

      this.imposter = null;

      this.scene.visible = true;

      this.scene.x = Global.xorigin;
      this.scene.y = Global.yorigin;

      this.scene.redraw( );
   }

   // redrawing during a zoom event may be laggy, the idea behind imposter zoom is to replace the scene
   // with a bitmap "imposter", and zoom that instead ( much faster/more responsive)
   public imposterZoom( zoom: number, mouse: PIXI.Point = null ): void
   {

      if ( zoom != Global.zoom )
      {

         if ( this.imposter == null )
         {
            this.imposter = new PIXI.Sprite( );

            let trans:Matrix = new Matrix( 1,0,0,1, Global.xorigin + this.stage.stageWidth/2,Global.yorigin + this.stage.stageHeight/2);

            if ( this.scene.width > 0 && this.scene.height > 0 )
            {
               try
               {
                  // draw everything that's visible, and a little bit more
                  let b:BitmapData = new BitmapData( this.stage.stageWidth*2, this.stage.stageHeight * 2, true, 0x000000 );
                  b.draw( scene, trans );

                  let bitmap:Bitmap =  new Bitmap( b, "auto", false );
                  bitmap.x = -Global.xorigin-stage.stageWidth/2;
                  bitmap.y = -Global.yorigin-stage.stageHeight/2;

                  this.imposter.addChild( bitmap );

               }
               catch( e:Error )
               {
                  // fallback to regular zoom when an error occurs
                  // this usually happens when the bitmap is too big
                  this.setZoom( zoom, mouse );
                  return;
               }
            }

            this.scene.visible = false;
         }

         if ( mouse == null)
         {
            Global.xorigin = Global.docwidth/2 - ( Global.docwidth/2 - Global.xorigin)*( zoom/Global.zoom);
            Global.yorigin = Global.docheight/2 - ( Global.docheight/2 - Global.yorigin)*( zoom/Global.zoom);
         }
         else
         {
            Global.xorigin = mouse.x - ( mouse.x - Global.xorigin) * ( zoom/Global.zoom);
            Global.yorigin = mouse.y - ( mouse.y - Global.yorigin) * ( zoom/Global.zoom);
         }

         this.addChild( this.imposter );

         Global.zoom = zoom;
         this.grid.setOrigin( );
         this.grid.redrawGrid( );
         this.redrawBackground( );

         this.imposter.x = Global.xorigin;
         this.imposter.y = Global.yorigin;

         this.imposter.width = 2 * this.stage.stageWidth * ( Global.zoom/startzoom );
         this.imposter.height = 2 * this.stage.stageHeight * ( Global.zoom/startzoom );
      }
   }

   public setZoom( zoom: number, mouse:Point = null ): void
   {
      // tools should be on top when zooming
      this.addChild( this.tools );

      if ( zoom != Global.zoom )
      {
         if ( mouse == null)
         {
            Global.xorigin = Global.docwidth/2 - ( Global.docwidth/2 - Global.xorigin)*( zoom/Global.zoom);
            Global.yorigin = Global.docheight/2 - ( Global.docheight/2 - Global.yorigin)*( zoom/Global.zoom );
         }
         else
         {
            Global.xorigin = mouse.x - ( mouse.x - Global.xorigin) * ( zoom/Global.zoom );
            Global.yorigin = mouse.y - ( mouse.y - Global.yorigin) * ( zoom/Global.zoom );
         }

         Global.zoom = zoom;
         this.grid.setOrigin( );
         this.grid.redrawGrid( );
         this.redrawBackground( );

         this.scene.x = Global.xorigin;
         this.scene.y = Global.yorigin;

         this.scene.redraw( );
      }
   }

   public redrawBackground(  ): void
   {
      if ( this.background.alpha != 0)
      {
         this.background.x = Global.xorigin;
         this.background.y = Global.yorigin;

         if ( this.background.numChildren > 0 )
         {
            let loader:Loader = this.background.getChildAt( 0 ) as Loader;
            let bit:Bitmap = this.loader.content as Bitmap;

            if ( bit != null )
            {
               this.background.width = ( bit.bitmapData.width/backgroundscale ) * Global.zoom;
               this.background.height = ( bit.bitmapData.height/backgroundscale ) * Global.zoom;
            }
         }
      }
   }

   public unitChange( e:Event ): void
   {
      let unitbox:ComboBox = e.target as ComboBox;

      let unit = unitbox.value;
      let i:int = 0;
      if ( Global.unit != unit )
      {
         if ( unit == "in" )
         {
            this.scene.cmToInch( );
            Global.zoom = Global.zoom*2.54;
         }
         else if (  unit == "cm" )
         {
            this.scene.inchToCm( );
            Global.zoom = Global.zoom/2.54;
         }
         this.grid.redrawGrid( );
         this.scene.redraw( );
         Global.unit = unit;
      }
   }

   public snapChange( e:Event ): void
   {
      Global.snap = e.target.selected;
   }

   public viewcutsChange( e:Event ): void
   {
      Global.viewcuts = e.target.selected;
      this.scene.redraw( );
   }

   public loadFile(  ): void
   {
      let sloader:SVGLoader = new SVGLoader( this);
      this.sloader.load( );
   }

   public saveFile(  ): void
   {

      // ensure there are paths to save
      if ( this.scene.pathlist.length == 0 )
      {
         this.startDialog( 140, 50, new Array( { type:"label", label:"No paths to save" }
         ), "error" );
         return;
      }

      let writer:SVGWriter = new SVGWriter( this.scene.pathlist, this.scene.cutlist );
      let save: string = writer.parse( );

      this.file = new FileReference( );
      this.file.save( save, "partkamdesign.svg");
      this.file.addEventListener( Event.CANCEL, this.saveCancel);
      this.file.addEventListener( Event.SELECT, this.saveBegin);
      this.file.addEventListener( ProgressEvent.PROGRESS, this.saveProgress);
      this.file.addEventListener( Event.COMPLETE, this.saveComplete);
   }

   public exportGcode( cutlist:Array ): void
   {

      let processor:PostProcessor = new PostProcessor( this.cutlist );
      let gcode: string = processor.process( );
      //			trace( gcode);
      if (  gcode != null)
      {
         this.file = new FileReference( );
         this.file.save( gcode, "part.nc");
         this.file.addEventListener( Event.CANCEL, this.saveCancel);
         this.file.addEventListener( Event.COMPLETE, this.saveComplete);
      }
   }

   public saveBegin( e:Event ): void
   {
      progressdialog = startProgressDialog( 250, 75, "Saving", "Cancel", this.saveProgressCancel);
      progressdialog.init( 1);
   }

   public saveCancel( e:Event ): void
   {
      this.removeFile( );
   }

   public saveProgressCancel( ): void
   {
      if ( this.file != null)
      {
         this.file.cancel( );
      }
      this.removeFile( );
   }

   public saveProgress( e:ProgressEvent ): void
   {
      progressdialog.setProgress( e.bytesLoaded/e.bytesTotal);
   }

   public saveComplete( e:Event ): void
   {
      this.removeFile( );
      if ( this.progressdialog != null)
      {
         this.progressdialog.stopDialog( );
      }
   }

   public removeFile(  ): void
   {
      if ( this.file != null)
      {
         this.file.removeEventListener( Event.CANCEL, this.saveCancel );
         this.file.removeEventListener( Event.SELECT, this.saveBegin );
         this.file.removeEventListener( ProgressEvent.PROGRESS, this.saveProgress );
         this.file.removeEventListener( Event.COMPLETE, this.saveComplete );
      }

      this.ile = null;
   }

   public processFile( svg:Object, svgxml:XML, clean:boolean = true ): void
   {
      let parser:SVGToPath = new SVGToPath( );
      let list:Array = parser.parse( svg);

      let miny: number = 0;

      if ( svg.height )
      {
         let h: string = svg.height.toString( );
         if (  h != "100%")
         {
            miny = parser.getUnit( h );
         }
      }

      //O for each( let path:Path in list )
      for ( let path:Path in list )
      {
         path.invertY( );
      }

      //O for each( path in list )
      for ( path in list )
      {
         path.docy -= miny;
      }

      this.scene.setInactive( );
      this.scene.addPaths( list );

      // post process step: separate and merge to ensure each loop is a separate path
      // and to join open segments often created by cad software
      if ( clean )
      {
         let pd:ProgressDialog = startProgressDialog( 250, 75, "Performing File Cleanup", "Stop Cleanup" );
         this.scene.processFile( pd, svgxml);
      }
      else
      {
         this.scene.loadCuts( svgxml );
      }
   }

   // modal dialog stuff

   public addScreen( ): void
   {
      Mouse.cursor = MouseCursor.AUTO;

      // first add screen and blur the background

      let s: PIXI.Shape = new PIXI.Shape( );

      s.graphics.beginFill( 0x000000);
      s.graphics.drawRect( 0,0,Global.docwidth,Global.docheight );
      s.graphics.endFill( );
      s.alpha = 0.1;

      let screen: PIXI.Sprite = new PIXI.Sprite( );

      this.screen.addChild( s );
      this.screen.name = "screen";
      this.addChild( this.screen );

      // now blur everything

      /*let blur:BlurFilter = new BlurFilter( 3, 3, 3 );
      //this.filters = [colorMat, blur];
      for( let i:int=0; i<numChildren; i++ ){
         if ( getChildAt( i) is PIXI.Sprite ){
            getChildAt( i).filters = [ blur ];
         }
      }*/
   }

   public startDialog( dw:int, dh:int, fieldlist:Array, dialogname: string, submitlabel: string = "OK", closewindow: boolean = true ): Dialog
   {

      this.addScreen( );

      let d:Dialog = new Dialog( dw, dh, fieldlist, submitlabel, closewindow);

      d.name = dialogname;

      d.x = Global.docwidth/2 - d.width/2;
      d.y = Global.docheight/2 - d.height/2;

      temptool = Global.tool;
      Global.tool = 99; // no tool may be used during modal dialog display
      this.addChild( d );

      return d;
   }

   public startProgressDialog( dw:int, dh:int, dmessage: string = "processing", dlabel: string = "Cancel", callback:Function = null ): ProgressDialog
   {

      this.addScreen( );

      let d:ProgressDialog = new ProgressDialog( dw, dh, dmessage, dlabel, callback);

      d.x = Global.docwidth/2 - dw/2;
      d.y = Global.docheight/2 - dh/2;

      temptool = Global.tool;
      Global.tool = 99;                                  // no tool may be used during modal dialog display
      this.addChild( d );

      return d;
   }

   public endDialog( ): void
   {
      // remove screen, blur, and restore everthing to original settings
      for( let i:int=0; i < numChildren; i++ )
      {
         if ( getChildAt( i) is PIXI.Sprite )
         {
            getChildAt( i ).filters = [];
            if ( getChildAt( i ).name == "screen" )
            {
               this.removeChildAt( i );
            }
         }
      }

      this.setCursor( );

      Global.tool = temptool;
   }

   public processDialog( flist:Array, dname: string ): void
   {
      // do something with dialog output

      this.stage.focus = this;

      let i:int = 0;
      switch( dname )
      {
         case "scale":
            let sx: number = Number( flist[0].input.text );
            let sy: number = Number( flist[1].input.text );

            let avx: number = 0;
            let avy: number = 0;

            let m:Matrix = new Matrix( sx/100, 0, 0, sy/100, avx, avy );

            if (  sx != 0 && sy != 0 )
            {
               this.scene.applyMatrixLocal( m );
            }
            break;
         case "rotate":
            let ang: number = Number( flist[0].input.text );
            let r:Matrix = new Matrix( );
            r.rotate( ang*Math.PI/180 );
            if ( ang != 0 && ang != 360n)
            {
               this.scene.applyMatrixLocal( rn);
            }
            break;
         case "skew":
            let skx: number = Number( flist[ 0 ].input.text );
            let sky: number = Number( flist[ 1 ].input.text );

            let s:Matrix = new Matrix( );
            s.c = Math.tan( ( -1*skx/100 ) );
            s.b = Math.tan( ( -1*sky/100 ) );

            scene.applyMatrixLocal( sn);
            break;
         case "background":
            if (  flist[0].input != null && flist[0].input is Loader)
            {
               while( this.background.numChildren > 0 )
               {
                  this.background.removeChildAt( 0 );
               }
               this.background.addChild( flist[0].input );
            }

            let scale: number = Number( flist[ 1 ].input.text );

            if ( !isNaN( scale) && scale != 0 )
            {
               if ( scale < 0)
               {
                  scale = Math.abs( scale );
               }

               this.backgroundscale = scale;

               this.redrawBackground( );
            }

            let al: number = Number( flist[2].input.text );

            if ( !isNaN( al ) )
            {
               if ( al>100)
               {
                  al = 100;
               }
               else if ( al < 0 )
               {
                  al = Math.abs( al );
               }
               this.background.alpha = al/100;
               this.backgroundvisibility = al;
            }
            break;
         case "preferences":
            let res: number = Number( flist[ 0 ].input.text );
            if ( !isNaN( res) && res != 0 )
            {
               if ( res < 0 )
               {
                  res = -res;
               }
               Global.importres = res;
            }

            let snap: boolean = flist[ 4 ].input.selected;
            Global.localsnap = snap;

            let tolerance: number = Number( flist[7].input.text );

            if ( !isNaN( tolerance) && tolerance != 0 )
            {
               if ( tolerance < 0 )
               {
                  tolerance = -tolerance;
               }
               Global.tolerance = tolerance;
            }

            let bitmaptolerance: number = Number( flist[ 8 ].input.text )

               if ( !isNaN( bitmaptolerance ) && bitmaptolerance != 0 )
            {
               if ( bitmaptolerance < 0)
               {
                  bitmaptolerance = -bitmaptolerance;
               }
               Global.bitmaptolerance = bitmaptolerance;
            }

            let nestbitmapsize: number = Number( flist[ 9 ].input.text )

            if ( !isNaN( nestbitmapsize ) )
            {
               if ( nestbitmapsize < 400 )
               {
                  nestbitmapsize = 400;
               }
               if ( nestbitmapsize > 4000 )
               {
                  nestbitmapsize = 4000;
               }
               Global.nestbitmapsize = Math.floor( nestbitmapsize );
            }
            Global.precision = int( flist[6].input.text );

            Global.separatetoolpaths = flist[10].input.selected;

            break;
         case "addcircle":
            let dia: number = Number( flist[0].input.text );
            if ( !isNaN( dia) && dia != 0 )
            {
               if ( dia < 0)
               {
                  dia = Math.abs( dia );
               }

               this.addEllipse( dia,dia);
            }
            break;
         case "addellipse":
            let ew: number = Number( flist[0].input.text );
            let eh: number = Number( flist[1].input.text );
            if ( !isNaN( ew ) && ew != 0 && !isNaN( eh ) && eh != 0 )
            {
               if ( ew < 0 )
               {
                  ew = Math.abs( ew );
               }
               if ( eh < 0)
               {
                  eh = Math.abs( eh );
               }

               this.addEllipse( ew,eh);
            }
            break;
         case "addrectangle":
            let rw: number = Number( flist[0].input.text );
            let rh: number = Number( flist[1].input.text );
            if ( !isNaN( rw ) && rw != 0 && !isNaN( rh ) && rh != 0 )
            {
               if ( rw < 0)
               {
                  rw = Math.abs( rw );
               }
               if ( rh < 0)
               {
                  rh = Math.abs( rh );
               }

               this.addRect( rw,rh,0, false);
            }
            break;
         case "addroundedrectangle":
            let rw1: number = Number( flist[ 0 ].input.text );
            let rh1: number = Number( flist[ 1 ].input.text );
            let rad: number = Number( flist[ 2 ].input.text );
            if ( !isNaN( rw1 ) && rw1 != 0 && !isNaN( rh1 ) && rh1 != 0 )
            {
               if ( rw1 < 0 )
               {
                  rw1 = Math.abs( rw1 );
               }
               if ( rh < 0)
               {
                  rh1 = Math.abs( rh1 );
               }
               if ( rad < 0)
               {
                  rad = Math.abs( rad );
               }

               this.addRect( rw1,rh1,rad, true );
            }
            break;
         case "addpolygon":
            let sides:int = Math.floor( Number( flist[0].input.text ) );
            let rad1: number = Number( flist[1].input.text);
            if ( !isNaN( sides ) && sides !=0 && !isNaN( rad1 ) && rad1 != 0 )
            {
               if ( sides < 0 )
               {
                  sides = Math.abs( sides );
               }
               if ( rad1 < 0 )
               {
                  rad1 = Math.abs( rad1 );
               }
               if ( sides >= 3)
               {
                  addPolygon( sides, rad1 );
               }
            }
            break;
         case "addstar":
            let points:int = Math.floor( Number( flist[0].input.text ) );
            let rad2: number = Number( flist[1].input.text);
            let pointiness: number = Number( flist[2].input.text );
            if ( !isNaN( points) && points !=0 && !isNaN( rad2 ) && rad2 != 0 && !isNaN( pointiness ) )
            {
               if ( points < 0 )
               {
                  points = Math.abs( points );
               }
               if ( rad2 < 0 )
               {
                  rad2 = Math.abs( rad1 );
               }
               if ( pointiness < 0)
               {
                  pointiness = Math.abs( pointiness );
               }
               if ( pointiness > 99 )
               {
                  pointiness = 99;
               }
               if ( points >= 3 )
               {
                  this.addStar( points, rad2, pointiness );
               }
            }
            break;
         case "profile":
            this.scene.zeroSelected( );
            this.scene.profile( flist );
            this.scene.pathsOnTop( );
            break;
         case "editprofile":
            this.scene.zeroSelected( );
            this.scene.editprofile( flist );
            this.scene.pathsOnTop( );
            break;
         case "pocket":
            this.scene.zeroSelected( );
            this.scene.pocket( flist );
            this.scene.pathsOnTop( );
            break;
         case "editpocket":
            this.scene.zeroSelected( );
            this.scene.editpocket( flist );
            this.scene.pathsOnTop( );
            break;
         case "followpath":
            this.scene.zeroSelected( );
            this.scene.followpath( flist );
            this.scene.pathsOnTop( );
            break;
         case "editfollowpath":
            this.scene.zeroSelected( );
            this.scene.editfollowpath( flist );
            this.scene.pathsOnTop( );
            break;
         case "drill":
            this.scene.zeroSelected( );
            this.scene.drill( flist );
            this.scene.pathsOnTop( );
            break;
         case "editdrill":
            this.scene.zeroSelected( );
            this.scene.editdrill( flist );
            this.scene.pathsOnTop( );
            break;
         case "batch":
            this.scene.zeroSelected( );
            this.scene.batch( flist );
            this.scene.pathsOnTop( );
            break;
         case "startnest":
            let pd:ProgressDialog = startProgressDialog( 250, 75, "Optimizing Nesting Solution", "Stop", this.scene.finishNest );

            let divs:int = Number( flist[ 0 ].input.text );
            let gap: number = Number( flist[ 1 ].input.text );
            let group: boolean = flist[ 2 ].input.selected;
            let groupprofile: boolean = flist[ 3 ].input.selected;

            if ( !this.scene.startNest( pd, divs, gap, group, groupprofile))
            {
               pd.stopDialog( );
               this.scene.redraw( );
               startDialog( 270, 50, new Array( {type:"label", label:"At least 2 objects are required for nesting"}
               ), "error");
            }
            break;
         case "tabs":
            let tabspacing: number = Number( flist[0].input.text);
            let tabwidth: number = Number( flist[1].input.text);
            let tabheight: number = Number( flist[2].input.text);

            if (  isNaN( tabspacing ) || tabspacing <= 0 || isNaN( tabwidth ) || tabwidth <= 0 || isNaN( tabheight ) || tabheight <= 0 || tabspacing <= tabwidth )
            {
               startDialog( 100, 50, new Array( {type:"label", label:"Invalid input" }
               ), "error");
               return;
            }
            this.scene.addTabsSelected( tabspacing, tabwidth, tabheight );
            break;
         case "exportgcode":
            let cutlist:Array = new Array( );
            let listitems:Array = flist[ 0 ].input.selectedItems;
            for( i=0; i < listitems.length; i++ )
            {
               let obj:Object = listitems[ i ];
               cutlist.push( obj.data );
            }
            if ( cutlist.length > 0 )
            {
               this.exportGcode( cutlist );
            }
            break;
      }
   }

   public addEllipse( ew: number, eh: number ): void
   {
      let middle:PIXI.Point = new PIXI.Point( ( ( Global.docwidth/2) - Global.xorigin)/Global.zoom, ( - ( Global.docheight/2) + Global.yorigin)/Global.zoom );

      let cx: number = middle.x;
      let cy: number = middle.y;
      let rx: number = ew/2;
      let ry: number = eh/2;

      let ob:Object = { cx:cx+Global.unit, cy:cy + Global.unit, rx:rx + Global.unit, ry:ry + Global.unit };

      let svgtemp:SVGToPath = new SVGToPath( );

      let p:Path = svgtemp.parseEllipse( ob );

      if ( p != null)
      {
         this.scene.addPath( p );
         this.scene.redraw( );
      }

      svgtemp = null;
   }

   public addRect( rw: number, rh: number, radius: number, round: boolean ): void
   {
      let middle:Point = new Point( ( ( Global.docwidth/2)-Global.xorigin)/Global.zoom, ( -( Global.docheight/2)+Global.yorigin)/Global.zoom);

      let ob:Object = {isRound: round, rx: radius + Global.unit, ry: radius + Global.unit, x: middle.x-rw/2 + Global.unit, y:middle.y - rh/2 + Global.unit, width:rw + Global.unit, height:rh + Global.unit};

      let svgtemp:SVGToPath = new SVGToPath( );

      let p:Path = svgtemp.parseRect( ob );

      if ( p != null)
      {
         this.scene.addPath( p );
         this.scene.redraw( );
      }

      svgtemp = null;
   }

   public addPolygon( sides: number, radius: number ): void
   {
      if (  sides < 3 )
      {
         sides = 3;
      }

      let p:Path = new Path( );

      //let radius: number = Global.docheight/( Global.zoom * 3 );

      // current point
      let cpoint: PIXI.Point;

      // point belonging to the previous segment
      let lpoint: PIXI.Point = new PIXI.Point( 0, radius );
      let origin: PIXI.Point = lpoint;
      //O for( let i:int=360/sides; i<360; i += 360/sides )
      for( let i = 360/sides; i < 360; i += 360/sides )
      {
         cpoint = new PIXI.Point( radius*Math.sin( i * Math.PI/180), radius * Math.cos( i * Math.PI/180));
         let seg:Segment = new Segment( lpoint, cpoint );
         lpoint = cpoint;
         p.addSegment( seg);
      }

      // close polygon
      seg = new Segment( cpoint, origin );
      p.addSegment( seg);

      let middle: PIXI.Point = new PIXI.Point( ( ( Global.docwidth/2) - Global.xorigin)/Global.zoom, ( - ( Global.docheight/2) + Global.yorigin)/Global.zoom );
      p.docx = middle.x;
      p.docy = -middle.y;

      this.scene.addPath( p);
      this.scene.redraw( );
   }

   public addStar( points: number, radius: number, pointiness: number ): void
   {
      if ( points < 3 )
      {
         points = 3;
      }

      let p:Path = new Path;

      let cpoint: PIXI.Point;                           // current point
      // point belonging to the previous segment
      let lpoint: PIXI.Point = new PIXI.Point( 0, radius );

      let origin:Point = lpoint;
      for( let i = 360/points; i < 360; i += 360/points )
      {
         cpoint = new PIXI.Point( radius * Math.sin( i * Math.PI/180 ), radius * Math.cos( i * Math.PI/180 ) );
         let ipoint:PIXI.Point = new PIXI.Point( radius * ( ( 100-pointiness)/100) * Math.sin( ( i-180/points) * Math.PI/180), radius * ( ( 100-pointiness)/100)*Math.cos( ( i-180/points) * Math.PI/180));

         let seg:Segment = new Segment( lpoint, ipoint );
         p.addSegment( seg);

         seg = new Segment( ipoint, cpoint );
         p.addSegment( seg );

         lpoint = cpoint;
      }

      // close star
      ipoint = new Point( radius*( ( 100-pointiness)/100) * Math.sin( ( i-180/points)*Math.PI/180), radius * ( ( 100-pointiness)/100)*Math.cos( ( i-180/points)*Math.PI/180));
      seg = new Segment( cpoint, ipoint);
      p.addSegment( seg );

      seg = new Segment( ipoint, origin);
      p.addSegment( seg );

      let middle: PIXI.Point = new PIXI.Point( ( ( Global.docwidth/2) - Global.xorigin)/Global.zoom, ( -( Global.docheight/2) + Global.yorigin)/Global.zoom );
      p.docx = middle.x;
      p.docy = -middle.y;

      this.scene.addPath( p );
      this.scene.redraw( );
   }

   // pen tools
   public startPen( e:  PIXI.interaction.InteractionEvent ): void
   {
      //Global.dragging = true;
      if ( this.pen == null )
      {
         this.pen = new Pen( new Point( scene.mouseX/Global.zoom, - this.scene.mouseY/Global.zoom ) );
         this.pen.mousedown = true;
         this.scene.addPath( this.pen );
         addEventListener( 'mousemove', this.movePen );
         addEventListener( 'mouseup', this.upPen );
      }
      else
      {
         pen.startPoint( new PIXI.Point( scene.mouseX/Global.zoom, -scene.mouseY/Global.zoom));
         pen.mousedown = true;
      }
   }

   public movePen( e: PIXI.interaction.InteractionEvent ): void
   {
      this.pen.setPosition( );
   }

   public upPen( e: PIXI.interaction.InteractionEvent ): void
   {
      this.pen.mousedown = false;
      this.pen.finishPoint( );
   }

   public finishPen(  ): void
   {
      if ( this.pen != null)
      {
         removeEventListener( 'mousemove', this.movePen );
         removeEventListener( 'mouseup', this.upPen );
         this.pen.redraw( );
         this.pen = null;
      }
   }

   // sketch tools
   public startSketch( e: PIXI.interaction.InteractionEvent ): void
   {
      if ( e.target is Dot)
      {
         this.sketchdot = e.target as Dot;
      }

      Global.dragging = true;

      this.sketch = new Sketch( new PIXI.Point( e.stageX,e.stageY));

      this.addChild( sketch );
      addEventListener( 'mousemove', this.moveSketch );
      addEventListener( 'mouseup', this.upSketch );
      this.stage.addEventListener( Event.MOUSE_LEAVE, this.upSketch );

      timer = new Timer( 0,0 );
      timer.addEventListener( TimerEvent.TIMER, this.timeIncrement );
      timer.start( );
   }

   public moveSketch( e: PIXI.interaction.InteractionEvent ): void
   {
      let p: PIXI.Point = new PIXI.Point( e.stageX, e.stageY );
      this.sketch.lineTo( p );
      this.sketch.addPoint( p );
      this.sketch.addTime( this.now );
   }

   public upSketch( e:Event ): void
   {
      removeEventListener( 'mousemove', this.moveSketch );
      removeEventListener( 'mouseup', this.upSketch );
      this.stage.removeEventListener( Event.MOUSE_LEAVE, this.upSketch );

      this.timer.removeEventListener( TimerEvent.TIMER, this.timeIncrement );
      this.now = 0;

      let path:Path = this.sketch.getPath( );

      if ( path != null)
      {
         path.docx = -Global.xorigin/Global.zoom;
         path.docy = -Global.yorigin/Global.zoom;

         path.x = -Global.xorigin;
         path.y = -Global.yorigin;

         if (  sketchdot != null)
         {
            this.sketchdot.looppath.mergePath( path, sketchdot.point);
            this.sketchdot.looppath.setInactive( );

            this.sketchdot = null;
         }
         else
         {
            // if it is not a continuation, check if the path should be closed
            if ( path.seglist.length > 2 )
            {
               let seglist:Array = path.seglist;
               let intersect: PIXI.Point = Global.lineIntersect( seglist[ 0 ].p1, seglist[0].p2, seglist[seglist.length-1].p1, seglist[seglist.length-1].p2, true );
               if ( intersect != null && !isNaN( intersect.x ) && !isNaN( intersect.y ))
               {
                  seglist[ 0 ].p1 = intersect;
                  seglist[ seglist.length-1 ].p2 = intersect;
               }
            }

            /*path.docx = -Global.xorigin/Global.zoom;
            path.docy = -Global.yorigin/Global.zoom;*/
            path.redrawDots( );
            this.scene.addPath( path );
         }
      }

      Global.dragging = false;
      this.removeChild( this.sketch );

   }

   public timeIncrement( e:TimerEvent ): void
   {
      this.now++;
   }
}
