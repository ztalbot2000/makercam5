//O package com.partkart{

//O import flash.display.*;
//O import flash.ui.Keyboard;
//O import flash.events.*;
//O import flash.text.*;
//O import flash.geom.Point;
//O import flash.geom.Rectangle;
//O import flash.utils.Timer;
//O import fl.controls.ComboBox;
//O import flash.ui.Mouse;
//O import flash.net.FileReference;
//O import fl.data.DataProvider;
//O import flash.filters.BlurFilter;
//O import flash.filters.ColorMatrixFilter;
//O import flash.geom.Matrix;
//O import flash.ui.MouseCursor;
//O import com.tink.display.HitTest;
//O import com.tink.display.HitTest;

import * as PIXI from 'pixi.js';
import { Graphics } from 'pixi.js';
import { Sprite } from 'pixi.js';
import { Global }  from "./Global";
import { Tab }  from "./Tab";
import { Individual }  from "./Individual";
import { Segment }  from "./Segment";

   //O the scene graph is a root node containing all rendered objects
   //O public class SceneGraph extends Sprite
export default class SceneGraph extends Sprite
{

   //O public var pathlist:Array = new Array(); // list of all paths
   public var pathlist:Array = new Array(); // list of all paths
   //O public var copylist:Array = new Array(); // copy/paste buffer
   public var copylist:Array = new Array(); // copy/paste buffer

   //O public var cutlist:Array = new Array(); // list of all cutobjects
   public var cutlist:Array = new Array(); // list of all cutobjects

   //O public var xstart:Number = 0;
   public var xstart:number = 0;
   //O public var ystart:Number = 0;
   public var ystart:number = 0;

   //O public var ctrl:Boolean = false;
   public var ctrl:boolean = false;

   //O private static var singleton:SceneGraph; // only one instance of the scene graph ias allowed
   private static var singleton:SceneGraph; // only one instance of the scene graph ias allowed

   //O private var progressdialog:ProgressDialog;
   private var progressdialog:ProgressDialog;

   //O public var nestpath:Path = null;
   public var nestpath:Path = null;
   //O private var nest:Nest = null;
   private var nest:Nest = null;

   //O list of cutobjects that is waiting to be processed (use for progress bar udpates)
   //O public var processlist:Array;
   public var processlist:Array;

   //O public function SceneGraph(caller: Function = null):void
   public function SceneGraph(caller: Function = null):void
   {
      //O if (caller != SceneGraph.getInstance)
      if (caller != SceneGraph.getInstance)
      {
         //O throw new Error ("SceneGraph is a singleton class, use getInstance() instead");
         throw new Error ("SceneGraph is a singleton class, use getInstance() instead");
      }
      //O if (SceneGraph.singleton != null)
      if (SceneGraph.singleton != null)
      {
         //O throw new Error( "Only one Singleton instance should be instantiated");
         throw new Error( "Only one Singleton instance should be instantiated");
      }
      //O this.cacheAsBitmap = true;
      this.cacheAsBitmap = true;
   }

   //O public static function getInstance():SceneGraph
   public static function getInstance():SceneGraph
   {
      //O if (singleton == null)
      if (singleton == null)
      {
         //O singleton = new SceneGraph(arguments.callee);
         singleton = new SceneGraph(arguments.callee);
      }
      //O return singleton;
      return singleton;
   }

   //O public function addPath(p:Path):void
   public function addPath(p:Path):void
   {
      //O addChild(p);
      addChild(p);
      //O p.render();
      p.render();
      //O pathlist.push(p);
      pathlist.push(p);
      //O p.addEventListener(MouseEvent.MOUSE_DOWN, pathMouseDown);
      p.addEventListener(MouseEvent.MOUSE_DOWN, pathMouseDown);
   }

   //O public function removePath(p:Path):Boolean
   public function removePath(p:Path):boolean
   {
      //O if (p && contains(p))
      if (p && contains(p))
      {
         //O removeChild(p);
         removeChild(p);
      }
      //O var index:int = pathlist.indexOf(p);
      var index:number = pathlist.indexOf(p);
      //O if (index == -1)
      if (index == -1)
      {
         //O return false;
         return false;
      }
      //O pathlist.splice(index,1);
      pathlist.splice(index,1);
      //O return true;
      return true;
   }

   //O public function addPaths(list:Array):void
   public function addPaths(list:Array):void
   {
      //O for(var i:int=0; i<list.length; i++)
      for(let i=0; i<list.length; i++)
      {
         //O addChild(list[i]);
         addChild(list[i]);
         //O pathlist.push(list[i]);
         pathlist.push(list[i]);
         //O list[i].addEventListener(MouseEvent.MOUSE_DOWN, pathMouseDown);
         list[i].addEventListener(MouseEvent.MOUSE_DOWN, pathMouseDown);
      }
      //O //redraw();
      //redraw();
      //O for(i=0; i<list.length; i++)
      for(i=0; i<list.length; i++)
      {
         //O list[i].setActive();
         list[i].setActive();
      }
   }

   //O public function setInactive():void
   public function setInactive():void
   {
      //O for(var i:int=0; i<pathlist.length; i++)
      for(let i=0; i<pathlist.length; i++)
      {
         //O pathlist[i].setInactive();
         pathlist[i].setInactive();
      }

      //O for(i=0; i<cutlist.length; i++)
      for(i=0; i<this.cutlist.length; i++){
         //O cutlist[i].setInactive();
         this.cutlist[i].setInactive();
      }
   }

   //O public function getActiveCuts():Array
   public function getActiveCuts():Array{
      //O var active:Array = new Array();
      var active:Array = new Array();
      //O for(var i:int=0; i<cutlist.length; i++)
      for(let i=0; i<this.cutlist.length; i++){
         //O if (cutlist[i].active == true)
         if (this.cutlist[i].active == true){
            //O active.push(cutlist[i]);
            active.push(this.cutlist[i]);
         }
      }
      //O return active;
      return active;
   }

   //O // removes dots and coordinate boxes from the screen, if p is defined, exclude p from clearing
   // removes dots and coordinate boxes from the screen, if p is defined, exclude p from clearing
   //O public function clearDots(p:Path = null):void
   public function clearDots(p:Path = null):void{
      //O for(var i:int = 0; i<pathlist.length; i++)
      for(let i = 0; i<pathlist.length; i++){
         //O if (p == null || (p != null && pathlist[i] != p))
         if (p == null || (p != null && pathlist[i] != p)){
            //O pathlist[i].setSegmentsInactive();
            pathlist[i].setSegmentsInactive();
            //O pathlist[i].setDotsInactive();
            pathlist[i].setDotsInactive();
            //O pathlist[i].clearDots();
            pathlist[i].clearDots();
         }
      }

      //O var removelist:Array = new Array();
      var removelist:Array = new Array();

      //O for(i = 0; i<numChildren; i++)
      for(i = 0; i<numChildren; i++){
         //O if ((getChildAt(i) is coordinates) && (p == null || (p != null && p.coord != getChildAt(i))))
         if ((getChildAt(i) is coordinates) && (p == null || (p != null && p.coord != getChildAt(i)))){
            //O removelist.push(getChildAt(i));
            removelist.push(getChildAt(i));
         }
      }

      //O for(i=0;i<removelist.length; i++)
      for(i=0;i<removelist.length; i++){
         //O removeChild(removelist[i]);
         removeChild(removelist[i]);
      }
   }

   //O public function addDots():void
   public function addDots():void{
      //O for each(var path:Path in pathlist)
      for each(var path:Path in pathlist)
      {
         //O path.redrawDots();
         path.redrawDots();
      }
   }

   //O public function redraw():void
   public function redraw():void{
      //O trace("redraw!");
      trace("redraw!");

      //O // no redrawing during calculations
      // no redrawing during calculations
      //O if (Global.tool != 99)
      if (Global.tool != 99){
         //O clearDots();
         clearDots();
         //O x = Global.xorigin;
         x = Global.xorigin;
         //O y = Global.yorigin;
         y = Global.yorigin;

         //O while(numChildren > 0)
         while(numChildren > 0){
            //O removeChildAt(0);
            removeChildAt(0);
         }

         //O // stack cutobjects at the bottom
         // stack cutobjects at the bottom
         //O for each(var cut:CutObject in cutlist)
         for each(var cut:CutObject in this.cutlist)
         {
            //O addChild(cut);
            addChild(cut);
         }

         //O // paths on top
         // paths on top
         //O for each(var path in pathlist)
         for each(var path in pathlist)
         {
            //O addChild(path);
            addChild(path);

            //O path.x = path.docx*Global.zoom;
            path.x = path.docx*Global.zoom;
            //O path.y = path.docy*Global.zoom;
            path.y = path.docy*Global.zoom;

            //O path.redraw();
            path.redraw();
         }

         //O redrawCuts();
         redrawCuts();
      }
   }

   //O public function redrawCuts():void
   public function redrawCuts():void{
      //O for each(var cutobject:CutObject in cutlist)
      for each(var cutobject:CutObject in this.cutlist)
      {
         //O cutobject.x = cutobject.docx*Global.zoom;
         cutobject.x = cutobject.docx*Global.zoom;
         //O cutobject.y = cutobject.docy*Global.zoom;
         cutobject.y = cutobject.docy*Global.zoom;

         //O cutobject.redraw();
         cutobject.redraw();
      }
      //O for each(cutobject in cutlist)
      for each(cutobject in this.cutlist)
      {
         //O if (cutobject.processed == false)
         if (cutobject.processed == false){
            //O for each(var path:Path in cutobject.pathlist)
            for each(var path:Path in cutobject.pathlist)
            {
               //O path.dirty = false;
               path.dirty = false;
            }
         }
      }
   }

   //O public function cmToInch():void
   public function cmToInch():void{
      //O for(var i:int=0; i<pathlist.length; i++)
      for(let i=0; i<pathlist.length; i++){
         //O pathlist[i].cmToInch();
         pathlist[i].cmToInch();
         //O pathlist[i].dirty = true;
         pathlist[i].dirty = true;
      }
      //O for(i=0; i<cutlist.length; i++)
      for(i=0; i<this.cutlist.length; i++)
      {
         //O if (cutlist[i].processed == true)
         if (this.cutlist[i].processed == true)
         {
            //O cutlist[i].cmToInch();
            this.cutlist[i].cmToInch();
         } else {
            //O cutlist[i].paramsCmToInch();
            this.cutlist[i].paramsCmToInch();
         }
      }

      //O Global.tolerance /= 2.54;
      Global.tolerance /= 2.54;
   }

   //O public function inchToCm():void
   public function inchToCm():void
   {
      //O for(var i:int=0; i<pathlist.length; i++)
      for(let i=0; i<pathlist.length; i++)
      {
         //O pathlist[i].inchToCm();
         pathlist[i].inchToCm();
         //O pathlist[i].dirty = true;
         pathlist[i].dirty = true;
      }
      //O for(i=0; i<cutlist.length; i++)
      for(i=0; i<this.cutlist.length; i++)
      {
         //O if (cutlist[i].processed == true)
         if (this.cutlist[i].processed == true)
         {
            //O cutlist[i].inchToCm();
            this.cutlist[i].inchToCm();
         } else {
            //O cutlist[i].paramsInchToCm();
            this.cutlist[i].paramsInchToCm();
         }
      }

      //O Global.tolerance *= 2.54;
      Global.tolerance *= 2.54;
   }

   //O public function pathMouseDown(e:MouseEvent):void
   public function pathMouseDown(e:MouseEvent):void
   {
      //O stage.focus = null;
      stage.focus = null;

      //O if (Global.tool == 3 && Global.space == false)
      if (Global.tool == 3 && Global.space == false)
      {
         //O e.stopPropagation();
         e.stopPropagation();
      }
      //O else if (Global.tool == 0 && Global.space == false)
      else if (Global.tool == 0 && Global.space == false)
      {
         //O e.stopPropagation();
         e.stopPropagation();

         //O var path:Path;
         var path:Path;

         //O if (e.target is Segment)
         if (e.target is Segment)
         {
            //O path = e.target.parent as Path;
            path = e.target.parent as Path;
         }
         //O else if (e.target is Path)
         else if (e.target is Path)
         {
            //O path = e.target as Path;
            path = e.target as Path;
         }

         //O if (path != null)
         if (path != null)
         {
            //O path.startDrag();
            path.startDrag();
            //O path.dragging = true;
            path.dragging = true;
            //O path.mouseChildren = false;
            path.mouseChildren = false;

            //O xstart = e.stageX;
            xstart = e.stageX;
            //O ystart = e.stageY;
            ystart = e.stageY;

            //O addChild(path); // put path on top of z-stack
            addChild(path); // put path on top of z-stack

            //O if (ctrl == true)
            if (ctrl == true)
            {
               //O if (path.active)
               if (path.active)
               {
                  //O path.setInactive();
                  path.setInactive();

               } else {
                  //O path.setActive();
                  path.setActive();
               }
            }
            //O else if (path.active == false || getPathNumActive() < 2)
            else if (path.active == false || getPathNumActive() < 2)
            {
               //O clearDots();
               clearDots();
               //O setInactive();
               setInactive();
               //O path.setActive();
               path.setActive();
            }

            //O for(var i:int = 0; i<pathlist.length; i++)
            for(let i = 0; i<pathlist.length; i++)
            {
               //O if (pathlist[i].active && pathlist[i] != path)
               if (pathlist[i].active && pathlist[i] != path)
               {
                  //O path.addChild(pathlist[i]);
                  path.addChild(pathlist[i]);

                  //O pathlist[i].x -= path.x;
                  pathlist[i].x -= path.x;
                  //O pathlist[i].y -= path.y;
                  pathlist[i].y -= path.y;
               }
            }

            //O for(i=0; i<cutlist.length; i++)
            for(i=0; i<this.cutlist.length; i++)
            {
               //O var parents:Array = cutlist[i].pathlist;
               var parents:Array = this.cutlist[i].pathlist;
               //O var movecut:Boolean = true;
               var movecut:boolean = true;
               //O for each(var p:Path in parents)
               for each(var p:Path in parents)
               {
                  //O if (p.active == false)
                  if (p.active == false)
                  {
                     //O movecut = false;
                     movecut = false;
                  }
               }
               //O if (movecut == true)
               if (movecut == true)
               {
                  //O path.addChild(cutlist[i]);
                  path.addChild(this.cutlist[i]);

                  //O cutlist[i].x -= path.x;
                  this.cutlist[i].x -= path.x;
                  //O cutlist[i].y -= path.y;
                  this.cutlist[i].y -= path.y;
               }
            }

            //O path.addEventListener(MouseEvent.MOUSE_UP, pathMouseUp);
            path.addEventListener(MouseEvent.MOUSE_UP, pathMouseUp);
         }
      }
   }

   //O public function pathMouseUp(e:MouseEvent, epath:Path = null):void
   public function pathMouseUp(e:MouseEvent, epath:Path = null):void
   {
      //O var path:Path;
      var path:Path;

      //O if (epath != null)
      if (epath != null)
      {
         //O path = epath;
         path = epath;
      }
      //O else if (e.target is Segment)
      else if (e.target is Segment)
      {
         //O path = e.target.parent as Path;
         path = e.target.parent as Path;
      }
      //O else if (e.target is Path)
      else if (e.target is Path)
      {
         //O path = e.target as Path;
         path = e.target as Path;
      }
      //O if (path != null)
      if (path != null)
      {

         //O while(path.parent is Path)
         while(path.parent is Path)
         {
            //O path = path.parent as Path;
            path = path.parent as Path;
         }

         //O path.stopDrag();
         path.stopDrag();
         //O path.dragging = false;
         path.dragging = false;
         //O path.mouseChildren = true;
         path.mouseChildren = true;

         //O trace("uppped");
         trace("uppped");
         //O if (path != null && Global.tool == 0) // don't do this stuff during sketching
         if (path != null && Global.tool == 0) // don't do this stuff during sketching
         {
            //O var xdelta:Number = e.stageX - xstart;
            var xdelta:number = e.stageX - xstart;
            //O var ydelta:Number = e.stageY - ystart;
            var ydelta:number = e.stageY - ystart;

            //O if (isNaN(xdelta))
            if (isNaN(xdelta))
            {
               //O xdelta = 0;
               xdelta = 0;
            }

            //O if (isNaN(ydelta))
            if (isNaN(ydelta))
            {
               //O ydelta = 0;
               ydelta = 0;
            }

            //O path.docx += xdelta/Global.zoom;
            path.docx += xdelta/Global.zoom;
            //O path.docy += ydelta/Global.zoom;
            path.docy += ydelta/Global.zoom;

            //O path.x = path.docx*Global.zoom;
            path.x = path.docx*Global.zoom;
            //O path.y = path.docy*Global.zoom;
            path.y = path.docy*Global.zoom;

            //O var plist:Array = new Array();
            var plist:Array = new Array();

            //O if (path)
            if (path)
            {
               //O var p:*;
               var p:*;
               //O for(var i=0; i<path.numChildren; i++)
               for(var i=0; i<path.numChildren; i++)
               {
                  //O p = path.getChildAt(i);
                  p = path.getChildAt(i);
                  //O if (p is Path || p is CutObject)
                  if (p is Path || p is CutObject)
                  {
                     //O plist.push(path.getChildAt(i));
                     plist.push(path.getChildAt(i));
                  }
               }

               //O for each(p in plist)
               for each(p in plist)
               {
                  //O p.docx += xdelta/Global.zoom;
                  p.docx += xdelta/Global.zoom;
                  //O p.docy += ydelta/Global.zoom;
                  p.docy += ydelta/Global.zoom;

                  //O p.x = p.docx*Global.zoom;
                  p.x = p.docx*Global.zoom;
                  //O p.y = p.docy*Global.zoom;
                  p.y = p.docy*Global.zoom;
                  //O this.addChild(p);
                  this.addChild(p);
               }
            }

            //O if (xdelta != 0 || ydelta != 0)
            if (xdelta != 0 || ydelta != 0)
            {
               //O setup undo
               //O var undo:UndoMove = new UndoMove(this);
               var undo:UndoMove = new UndoMove(this);
               //O undo.xdelta = xdelta/Global.zoom;
               undo.xdelta = xdelta/Global.zoom;
               //O undo.ydelta = ydelta/Global.zoom;
               undo.ydelta = ydelta/Global.zoom;
               //O undo.pathlist = plist;
               undo.pathlist = plist;
               //O undo.pathlist.push(path);
               undo.pathlist.push(path);

               //O Global.undoPush(undo);
               Global.undoPush(undo);

               //O if the paths of a cutobject are all moved at once, they are not dirty. Otherwise the path is dirty
               /*
//O               var clist:Array = new Array();
//O               for each(p in plist){
//O                  if (p is CutObject){
//O                     clist.push(p);
//O                  }
//O               }
               */
               //O for each(var c:CutObject in cutlist)
               for each(var c:CutObject in this.cutlist)
               {
                  //O var moved:int = 0;
                  let moved: number = 0;
                  //O for each(path in c.pathlist)
                  for each(path in c.pathlist)
                  {
                     //O if (plist.indexOf(path) != -1)
                     if (plist.indexOf(path) != -1)
                     {
                        //O moved++;
                        moved++;
                     }
                  }
                  //O if (moved > 0 && moved < c.pathlist.length)
                  if (moved > 0 && moved < c.pathlist.length)
                  {
                     //O for each(path in c.pathlist)
                     for each(path in c.pathlist)
                     {
                        //O if (plist.indexOf(path) != -1)
                        if (plist.indexOf(path) != -1)
                        {
                           //O path.dirty = true;
                           path.dirty = true;
                           //O path.camdirty = true;
                           path.camdirty = true;
                        }
                     }
                  }
               }
            }
         }

         //O paths on top
         //O for(i=0; i<pathlist.length; i++)
         for(i=0; i<pathlist.length; i++)
         {
            //O addChild(pathlist[i]);
            addChild(pathlist[i]);
         }

         //O path.removeEventListener(MouseEvent.MOUSE_UP, pathMouseUp);
         path.removeEventListener(MouseEvent.MOUSE_UP, pathMouseUp);
      }

      //O redrawCuts();
      redrawCuts();
   }

   //O fires mouseup events when mouse leaves stage
   //O public function mouseLeave():void
   public function mouseLeave():void
   {
      //O for(var i:int = 0; i<pathlist.length; i++)
      for(let i = 0; i<pathlist.length; i++)
      {
         //O if (pathlist[i].dragging == true)
         if (pathlist[i].dragging == true)
         {
            //O pathMouseUp(new MouseEvent(MouseEvent.MOUSE_UP), pathlist[i]);
            pathMouseUp(new MouseEvent(MouseEvent.MOUSE_UP), pathlist[i]);
         }
         //O pathlist[i].pubPointUpAction();
         pathlist[i].pubPointUpAction();
      }
   }

   //O public function select(selectbox:Sprite):void
   public function select(selectbox:Sprite):void
   {
      //O set selected paths to active

      //O var perfect:Boolean = true;
      var perfect:boolean = true;

      //O if (pathlist.length > 1000) // when you're selecting more than 1000 elements, you're probably not going for accuracy
      if (pathlist.length > 1000) // when you're selecting more than 1000 elements, you're probably not going for accuracy
      {
         //O perfect = false;
         perfect = false;
      }

      //O selectbox.alpha = 1;
      selectbox.alpha = 1;

      //O for(var i:int=0; i<pathlist.length; i++)
      for(let i=0; i<pathlist.length; i++)
      {
         //O if (HitTest.complexHitTestObject(selectbox, pathlist[i]))
         if (HitTest.complexHitTestObject(selectbox, pathlist[i]))
         {
            //O if (pathlist[i].active)
            if (pathlist[i].active)
            {
               //O pathlist[i].setInactive();
               pathlist[i].setInactive();

            } else
            {
               //O pathlist[i].setActive();
               pathlist[i].setActive();
            }
         }
      }

      //O for(i=0; i<cutlist.length; i++)
      for(i=0; i<this.cutlist.length; i++)
      {
         //O if (HitTest.complexHitTestObject(selectbox, cutlist[i]))
         if (HitTest.complexHitTestObject(selectbox, this.cutlist[i]))
         {
            //O if (cutlist[i].active)
            if (this.cutlist[i].active)
            {
               //O cutlist[i].setInactive();
               this.cutlist[i].setInactive();
            } else
            {
               //O cutlist[i].setActive();
               this.cutlist[i].setActive();
            }
         }
      }
   }

   //O public function deleteSelected():void
   public function deleteSelected():void{

      //O // keep track of removed cuts/paths
      // keep track of removed cuts/paths
      //O var removedcuts:Array = new Array();
      var removedcuts:Array = new Array();
      //O var removedpaths:Array = new Array();
      var removedpaths:Array = new Array();
      //O // keeps track of parent relationships between cuts and paths
      // keeps track of parent relationships between cuts and paths
      //O var cutparent:Array = new Array();
      var cutparent:Array = new Array();

      //O var i:int;
      var i: number;

      //O remove selected paths from cutlist
      //O for(i=0; i<cutlist.length; i++)
      for(i=0; i<this.cutlist.length; i++)
      {
         //O for(var j:int=0; j<pathlist.length; j++)
         for(let j=0; j<pathlist.length; j++){
            //O var dirty:Boolean = false;
            var dirty:boolean = false;

            //O if (pathlist[j].active == true)
            if (pathlist[j].active == true)
            {
               //O cutparent.push({cut:cutlist[i], path:pathlist[j]});
               cutparent.push({cut:this.cutlist[i], path:pathlist[j]});
               //O var index:int = cutlist[i].pathlist.indexOf(pathlist[j]);
               var index: number = this.cutlist[i].pathlist.indexOf(pathlist[j]);
               //O if (index != -1)
               if (index != -1){
                  //O cutlist[i].pathlist.splice(index,1);
                  this.cutlist[i].pathlist.splice(index,1);
                  //O dirty = true;
                  dirty = true;
               }
            }
            //O // delete the cutobject if it has no paths left
            // delete the cutobject if it has no paths left
            //O if (cutlist[i].pathlist.length == 0)
            if (this.cutlist[i].pathlist.length == 0){
               //O var cut:CutObject = cutlist[i];
               var cut:CutObject = this.cutlist[i];
               //O if (removeCut(cut))
               if (removeCut(cut)){
                  //O removedcuts.push(cut);
                  removedcuts.push(cut);
                  //O i--;
                  i--;
                  //O break;
                  break;
               }
            }
            //O else if (dirty)
            else if (dirty)
            {
               //O cutlist[i].pathlist[0].dirty = true;
               this.cutlist[i].pathlist[0].dirty = true;
               //O cutlist[i].pathlist[0].camdirty = true;
               this.cutlist[i].pathlist[0].camdirty = true;
            }
         }
      }

      //O i=0;
      i=0;

      //O var path:Path;
      var path:Path;

      //O remove selected paths from pathlist, remove selected segments
      //O while(i<pathlist.length)
      while(i<pathlist.length)
      {
         //O path = pathlist[i];
         path = pathlist[i];

         //O if (path.active == true)
         if (path.active == true)
          {
            //O removedpaths.push(path);
            removedpaths.push(path);
            //O if (removePath(path))
            if (removePath(path))
            {
               //O i--;
               i--;
            }
         } else
         {
            //O if (path.deleteActive() == true)
            if (path.deleteActive() == true)
            {
               //O if (removePath(path))
               if (removePath(path))
               {
                  //O i--;
                  i--;
               }
            }
         }
         //O i++;
         i++;
      }

      //O for(i=0; i<cutlist.length; i++)
      for(i=0; i<this.cutlist.length; i++)
      {
         //O cut = cutlist[i];
         cut = this.cutlist[i];
         //O if (cutlist[i].active == true)
         if (this.cutlist[i].active == true)
         {
            //O if (removeCut(cut))
            if (removeCut(cut))
            {
               //O removedcuts.push(cut);
               removedcuts.push(cut);
               //O i--;
               i--;
            }
         }
      }

      //O if (removedpaths.length > 0 || removedcuts.length > 0)
      if (removedpaths.length > 0 || removedcuts.length > 0)
      {
         //O set up undo
         //O var undo:UndoDelete = new UndoDelete(this);
         var undo:UndoDelete = new UndoDelete(this);
         //O undo.pathlist = removedpaths;
         undo.pathlist = removedpaths;
         //O undo.cutlist = removedcuts;
         undo.this.cutlist = removedcuts;
         //O undo.cutparent = cutparent;
         undo.cutparent = cutparent;

         //O Global.undoPush(undo);
         Global.undoPush(undo);
      }

      //O remove tabs
      //O for(i=0; i<cutlist.length; i++)
      for(i=0; i<this.cutlist.length; i++)
      {
         //O cutlist[i].removeActiveTabs();
         this.cutlist[i].removeActiveTabs();
      }

      //O clearDots();
      clearDots();
   }

   //O public function getPathNumActive():int
   public function getPathNumActive(): number
   {
      //O var n:int = 0;
      var n: number = 0;
      //O for(var i:int=0; i<pathlist.length; i++)
      for(let i: number=0; i<pathlist.length; i++)
      {
         //O if (pathlist[i].active == true)
         if (pathlist[i].active == true)
         {
            //O n++;
            n++;
         }
      }

      //O return n;
      return n;
   }

   //O public function startCopy():void
   public function startCopy():void
   {
      //O copylist = new Array();
      copylist = new Array();

      //O for(var i:int=0; i<pathlist.length; i++)
      for(let i=0; i<pathlist.length; i++)
      {
         //O if (pathlist[i].active == true)
         if (pathlist[i].active == true)
         {
            //O var p:Path = pathlist[i].clone();
            var p:Path = pathlist[i].clone();
            //O //p.redrawDots();
            //p.redrawDots();
            //O copylist.push(p);
            copylist.push(p);
         }
      }
   }

   //O public function startPaste(p:Point = null):void
   public function startPaste(p:Point = null):void
   {

      //O // if given a point, align pasted paths to that point
      // if given a point, align pasted paths to that point

      //O setInactive();
      setInactive();

      //O if (p != null && copylist.length > 0)
      if (p != null && copylist.length > 0)
      {
         //O var min:Point = copylist[0].getMin().clone();
         var min:Point = copylist[0].getMin().clone();
         //O for(var j:int=0; j<copylist.length; j++)
         for(let j=0; j<copylist.length; j++)
         {
            //O var m:Point = copylist[j].getMin();
            var m:Point = copylist[j].getMin();
            //O if (m.x < min.x)
            if (m.x < min.x)
            {
               //O min.x = m.x;
               min.x = m.x;
            }
            //O if (m.y < min.y)
            if (m.y < min.y)
            {
               //O min.y = m.y;
               min.y = m.y;
            }
         }

         //O var diff:Point = new Point(p.x-min.x, p.y-min.y);
         var diff:Point = new Point(p.x-min.x, p.y-min.y);

         //O for(j=0; j<copylist.length; j++)
         for(j=0; j<copylist.length; j++)
         {
            //O copylist[j].docx += diff.x;
            copylist[j].docx += diff.x;
            //O copylist[j].docy -= diff.y;
            copylist[j].docy -= diff.y;

            //O copylist[j].x = copylist[j].docx*Global.zoom + Global.xorigin;
            copylist[j].x = copylist[j].docx*Global.zoom + Global.xorigin;
            //O copylist[j].y = -copylist[j].docy*Global.zoom + Global.yorigin;
            copylist[j].y = -copylist[j].docy*Global.zoom + Global.yorigin;
         }
      }

      //O addPaths(copylist);
      addPaths(copylist);
      //O redraw();
      redraw();

      //O var newlist:Array = new Array();
      var newlist:Array = new Array();
      //O for(var i:int=0; i<copylist.length; i++)
      for(let i=0; i<copylist.length; i++)
      {
         //O newlist.push(copylist[i].clone());
         newlist.push(copylist[i].clone());
      }

      //O copylist = newlist;
      copylist = newlist;
   }

   //O applies the given matrix as a local transform on selected paths
   //O public function applyMatrixLocal(m:Matrix):void
   public function applyMatrixLocal(m:Matrix):void
   {
      //O applies the given matrix transform to all active paths

      //O now we normalize the result so that the middle point of the previous and current spaces are identical

      //O var average:Point = new Point(0,0);
      var average:Point = new Point(0,0);
      //O var len:int = 0;
      var len: number = 0;

      //O for(var i:int=0; i<pathlist.length; i++)
      for(let i=0; i<pathlist.length; i++)
      {
         //O if (pathlist[i].active == true)
         if (pathlist[i].active == true)
         {
            //O var pathav:Point = pathlist[i].getAverage();
            var pathav:Point = pathlist[i].getAverage();
            //O average.x += pathav.x;
            average.x += pathav.x;
            //O average.y += pathav.y;
            average.y += pathav.y;

            //O len++;
            len++;
         }
      }

      //O average.x = average.x/len;
      average.x = average.x/len;
      //O average.y = average.y/len;
      average.y = average.y/len;

      //O var newaverage:Point = m.transformPoint(average);
      var newaverage:Point = m.transformPoint(average);

      //O var dis:Point = new Point(newaverage.x-average.x, newaverage.y-average.y);
      var dis:Point = new Point(newaverage.x-average.x, newaverage.y-average.y);

      //O // apply the matrix now
      // apply the matrix now
      //O for(i=0; i<pathlist.length; i++)
      for(i=0; i<pathlist.length; i++)
      {
         //O if (pathlist[i].active == true)
         if (pathlist[i].active == true)
         {
            //O pathlist[i].matrixTransform(m);
            pathlist[i].matrixTransform(m);
            //O var newdoc:Point = m.transformPoint(new Point(pathlist[i].docx, -pathlist[i].docy));
            var newdoc:Point = m.transformPoint(new Point(pathlist[i].docx, -pathlist[i].docy));
            //O pathlist[i].docx = newdoc.x;
            pathlist[i].docx = newdoc.x;
            //O pathlist[i].docy = -newdoc.y;
            pathlist[i].docy = -newdoc.y;
         }
      }

      //O normalize
      //O for(i=0; i<pathlist.length; i++)
      for(i=0; i<pathlist.length; i++)
      {
         //O if (pathlist[i].active == true)
         if (pathlist[i].active == true)
         {
            //O pathlist[i].docx -= dis.x;
            pathlist[i].docx -= dis.x;
            //O pathlist[i].docy += dis.y;
            pathlist[i].docy += dis.y;
         }
      }

      //O redraw();
      redraw();
   }

   //O public function closeLoop(dot:Dot):Point
   public function closeLoop(dot:Dot):Point
   {
      //O var snappoint:Point;
      var snappoint:Point;
      //O for(var i:int=0; i<pathlist.length; i++)
      for(let i=0; i<pathlist.length; i++)
      {
         //O snappoint = pathlist[i].snapPoint(dot);
         snappoint = pathlist[i].snapPoint(dot);
         //O if (snappoint != null)
         if (snappoint != null)
         {
            //O if (dot)
            if (dot)
            {
               //O dot.looppath = pathlist[i];
               dot.looppath = pathlist[i];
            }
            //O return snappoint;
            return snappoint;
         }
      }

      //O return null;
      return null;
   }

   //O CAM operations start here
   // CAM operations start here

   //O public function profile(flist:Array):void
   public function profile(flist:Array):void
   {

      //O filter input
      //O var cutname:String = String(flist[0].input.text);
      var cutname:String = String(flist[0].input.text);
      //O var tooldiameter:Number = Math.abs(Number(flist[1].input.text));
      var tooldiameter:number = Math.abs(Number(flist[1].input.text));
      //O var targetdepth:Number = Number(flist[2].input.text);
      var targetdepth:number = Number(flist[2].input.text);
      //O var outside:Boolean = flist[3].input.selectedItem.data;
      var outside:boolean = flist[3].input.selectedItem.data;
      //O var safetyheight:Number = Number(flist[4].input.text);
      var safetyheight:number = Number(flist[4].input.text);
      //O var stocksurface:Number = Number(flist[5].input.text);
      var stocksurface:number = Number(flist[5].input.text);
      //O var stepdown:Number = Math.abs(Number(flist[6].input.text));
      var stepdown:number = Math.abs(Number(flist[6].input.text));
      //O var feedrate:Number = Math.abs(Number(flist[7].input.text));
      var feedrate:number = Math.abs(Number(flist[7].input.text));
      //O var plungerate:Number = Math.abs(Number(flist[8].input.text));
      var plungerate:number = Math.abs(Number(flist[8].input.text));
      //O var dir:int = flist[9].input.selectedItem.data;
      var dir:int = flist[9].input.selectedItem.data;

      //O if (Global.unit == "cm")
      if (Global.unit == "cm")
      {
         //O // internal units are cm whereas machining units are given in mm
         // internal units are cm whereas machining units are given in mm
         //O tooldiameter /= 10;
         tooldiameter /= 10;
      }

      //O if (isNaN(safetyheight) || isNaN(stocksurface) || isNaN(targetdepth) || isNaN(tooldiameter) || tooldiameter == 0 || isNaN(stepdown) || stepdown == 0 || isNaN(feedrate) || feedrate == 0 || isNaN(plungerate) || plungerate == 0)
      if (isNaN(safetyheight) || isNaN(stocksurface) || isNaN(targetdepth) || isNaN(tooldiameter) || tooldiameter == 0 || isNaN(stepdown) || stepdown == 0 || isNaN(feedrate) || feedrate == 0 || isNaN(plungerate) || plungerate == 0)
      {
         //O return;
         return;
      }

      //O var selectedpaths:Array = new Array();
      var selectedpaths:Array = new Array();
      //O for(var i:int=0; i<pathlist.length; i++)
      for(let i=0; i<pathlist.length; i++) 
      {
         //O if (pathlist[i].active == true)
         if (pathlist[i].active == true) 
         {
            //O selectedpaths.push(pathlist[i]);
            selectedpaths.push(pathlist[i]);
         }
      }

      //O var cut:ProfileCutObject = new ProfileCutObject();
      var cut:ProfileCutObject = new ProfileCutObject();

      //O cut.name = cutname;
      cut.name = cutname;
      //O cut.outside = outside;
      cut.outside = outside;
      //O cut.safetyheight = safetyheight;
      cut.safetyheight = safetyheight;
      //O cut.stocksurface = stocksurface;
      cut.stocksurface = stocksurface;
      //O cut.targetdepth = targetdepth;
      cut.targetdepth = targetdepth;
      //O cut.tooldiameter = tooldiameter;
      cut.tooldiameter = tooldiameter;
      //O cut.stepdown = stepdown;
      cut.stepdown = stepdown;
      //O cut.feedrate = feedrate;
      cut.feedrate = feedrate;
      //O cut.plungerate = plungerate;
      cut.plungerate = plungerate;
      //O cut.dir = dir;
      cut.dir = dir;

      //O cut.pathlist = selectedpaths;
      cut.pathlist = selectedpaths;

      //O addCut(cut);
      addCut(cut);

      //O //var result:Array = cut.process(selectedpaths);
      //var result:Array = cut.process(selectedpaths);

      /*
//O      if (result == null || result.length == 0)
//O      {
//O         removeChild(cut);
//O         cutlist.splice(cutlist.indexOf(cut),1);
//O      }
      */

      //O redraw();
      redraw();
   }

   //O public function editprofile(flist:Array):void
   public function editprofile(flist:Array):void
   {

      //O // filter input
      // filter input
      //O var cutname:String = String(flist[0].input.text);
      var cutname:String = String(flist[0].input.text);
      //O var tooldiameter:Number = Math.abs(Number(flist[1].input.text));
      var tooldiameter:number = Math.abs(Number(flist[1].input.text));
      //O var targetdepth:Number = Number(flist[2].input.text);
      var targetdepth:number = Number(flist[2].input.text);
      //O var outside:Boolean = flist[3].input.selectedItem.data;
      var outside:boolean = flist[3].input.selectedItem.data;
      //O var safetyheight:Number = Number(flist[4].input.text);
      var safetyheight:number = Number(flist[4].input.text);
      //O var stocksurface:Number = Number(flist[5].input.text);
      var stocksurface:number = Number(flist[5].input.text);
      //O var stepdown:Number = Math.abs(Number(flist[6].input.text));
      var stepdown:number = Math.abs(Number(flist[6].input.text));
      //O var feedrate:Number = Math.abs(Number(flist[7].input.text));
      var feedrate:number = Math.abs(Number(flist[7].input.text));
      //O var plungerate:Number = Math.abs(Number(flist[8].input.text));
      var plungerate:number = Math.abs(Number(flist[8].input.text));
      //O var dir:int = flist[9].input.selectedItem.data;
      var dir: number = flist[9].input.selectedItem.data;

      //O if (Global.unit == "cm")
      if (Global.unit == "cm")
      {
         //O internal units are cm whereas machining units are given in mm
         //O tooldiameter /= 10;
         tooldiameter /= 10;
      }

      //O var main:* = this.parent;
      var main:* = this.parent;

      //O var cut:ProfileCutObject = main.tools.dToolpaths.selectedItem.data;
      var cut:ProfileCutObject = main.tools.dToolpaths.selectedItem.data;

      //O var redrawcut:Boolean = false;
      var redrawcut:boolean = false;
      //O if (cut.tooldiameter != tooldiameter || cut.outside != outside || cut.dir != dir)
      if (cut.tooldiameter != tooldiameter || cut.outside != outside || cut.dir != dir)
      {
         //O redrawcut = true;
         redrawcut = true;
      }

      //O cut.name = cutname;
      cut.name = cutname;
      //O main.tools.dToolpaths.selectedItem.label = cutname;
      main.tools.dToolpaths.selectedItem.label = cutname;
      //O cut.outside = outside;
      cut.outside = outside;
      //O cut.safetyheight = isNaN(safetyheight) ? cut.safetyheight : safetyheight;
      cut.safetyheight = isNaN(safetyheight) ? cut.safetyheight : safetyheight;
      //O cut.stocksurface = isNaN(stocksurface) ? cut.stocksurface : stocksurface;
      cut.stocksurface = isNaN(stocksurface) ? cut.stocksurface : stocksurface;
      //O cut.targetdepth = isNaN(targetdepth) ? cut.targetdepth : targetdepth;
      cut.targetdepth = isNaN(targetdepth) ? cut.targetdepth : targetdepth;
      //O cut.tooldiameter = (isNaN(tooldiameter) || tooldiameter == 0) ? cut.tooldiameter : tooldiameter;
      cut.tooldiameter = (isNaN(tooldiameter) || tooldiameter == 0) ? cut.tooldiameter : tooldiameter;
      //O cut.stepdown = (isNaN(stepdown) || stepdown == 0) ? cut.stepdown : stepdown;
      cut.stepdown = (isNaN(stepdown) || stepdown == 0) ? cut.stepdown : stepdown;
      //O cut.feedrate = (isNaN(feedrate) || feedrate == 0) ? cut.feedrate : feedrate;
      cut.feedrate = (isNaN(feedrate) || feedrate == 0) ? cut.feedrate : feedrate;
      //O cut.plungerate = (isNaN(plungerate) || plungerate == 0) ? cut.plungerate : plungerate;
      cut.plungerate = (isNaN(plungerate) || plungerate == 0) ? cut.plungerate : plungerate;
      //O cut.dir = dir;
      cut.dir = dir;

      //O if (redrawcut)
      if (redrawcut)
      {
         //O cut.pathlist[0].dirty = true;
         cut.pathlist[0].dirty = true;
         //O cut.pathlist[0].camdirty = true;
         cut.pathlist[0].camdirty = true;
         //O cut.processed = false;
         cut.processed = false;
         //O redraw();
         redraw();
      }
   }

   //O public function pocket(flist:Array):void
   public function pocket(flist:Array):void
   {

      //O filter input
      //O var cutname:String = String(flist[0].input.text);
      var cutname:String = String(flist[0].input.text);
      //O var tooldiameter:Number = Math.abs(Number(flist[1].input.text));
      var tooldiameter:number = Math.abs(Number(flist[1].input.text));
      //O var targetdepth:Number = Number(flist[2].input.text);
      var targetdepth:number = Number(flist[2].input.text);
      //O var safetyheight:Number = Number(flist[3].input.text);
      var safetyheight:number = Number(flist[3].input.text);
      //O var stocksurface:Number = Number(flist[4].input.text);
      var stocksurface:number = Number(flist[4].input.text);
      //O var stepover:Number = 0.01*Math.abs(Number(flist[5].input.text));
      var stepover:number = 0.01*Math.abs(Number(flist[5].input.text));
      //O var stepdown:Number = Math.abs(Number(flist[6].input.text));
      var stepdown:number = Math.abs(Number(flist[6].input.text));
      //O var roughingclearance:Number = Math.abs(Number(flist[7].input.text));
      var roughingclearance:number = Math.abs(Number(flist[7].input.text));
      //O var feedrate:Number = Math.abs(Number(flist[8].input.text));
      var feedrate:number = Math.abs(Number(flist[8].input.text));
      //O var plungerate:Number = Math.abs(Number(flist[9].input.text));
      var plungerate:number = Math.abs(Number(flist[9].input.text));
      //O var dir:int = flist[10].input.selectedItem.data;
      var dir: number = flist[10].input.selectedItem.data;

      //O if (Global.unit == "cm")
      if (Global.unit == "cm")
      {
         //O internal units are cm whereas machining units are given in mm
         //O tooldiameter /= 10;
         tooldiameter /= 10;
         //O roughingclearance /= 10;
         roughingclearance /= 10;
      }

      //O if (isNaN(safetyheight) || isNaN(stocksurface) || isNaN(targetdepth) || isNaN(tooldiameter) || isNaN(stepdown) || stepdown == 0 || isNaN(stepover) || stepover == 0 || isNaN(feedrate) || feedrate == 0 || isNaN(plungerate) || plungerate == 0 || isNaN(roughingclearance))
      if (isNaN(safetyheight) || isNaN(stocksurface) || isNaN(targetdepth) || isNaN(tooldiameter) || isNaN(stepdown) || stepdown == 0 || isNaN(stepover) || stepover == 0 || isNaN(feedrate) || feedrate == 0 || isNaN(plungerate) || plungerate == 0 || isNaN(roughingclearance))
      {
         //O return;
         return;
      }

      //O var selectedpaths:Array = new Array();
      var selectedpaths:Array = new Array();
      //O for(var i:int=0; i<pathlist.length; i++)
      for(let i=0; i<pathlist.length; i++)
      {
         //O if (pathlist[i].active == true)
         if (pathlist[i].active == true)
         {
            //O selectedpaths.push(pathlist[i]);
            selectedpaths.push(pathlist[i]);
         }
      }

      //O var cut:PocketCutObject = new PocketCutObject();
      var cut:PocketCutObject = new PocketCutObject();

      //O cut.name = cutname;
      cut.name = cutname;
      //O cut.safetyheight = safetyheight;
      cut.safetyheight = safetyheight;
      //O cut.stocksurface = stocksurface;
      cut.stocksurface = stocksurface;
      //O cut.targetdepth = targetdepth;
      cut.targetdepth = targetdepth;
      //O cut.tooldiameter = tooldiameter;
      cut.tooldiameter = tooldiameter;
      //O cut.stepover = stepover;
      cut.stepover = stepover;
      //O cut.stepdown = stepdown;
      cut.stepdown = stepdown;
      //O cut.roughingclearance = roughingclearance;
      cut.roughingclearance = roughingclearance;
      //O cut.feedrate = feedrate;
      cut.feedrate = feedrate;
      //O cut.plungerate = plungerate;
      cut.plungerate = plungerate;
      //O cut.dir = dir;
      cut.dir = dir;

      //O cut.pathlist = selectedpaths;
      cut.pathlist = selectedpaths;

      //O addCut(cut);
      addCut(cut);

      //O //var result:Array = cut.process(selectedpaths);
      //var result:Array = cut.process(selectedpaths);

      //O /*if (result == null || result.length == 0)
      /*if (result == null || result.length == 0){
         //O removeChild(cut);
         removeChild(cut);
         //O cutlist.splice(cutlist.indexOf(cut),1);
         cutlist.splice(cutlist.indexOf(cut),1);
      }*/

      //O redraw();
      redraw();
   }

   //O public function editpocket(flist:Array):void
   public function editpocket(flist:Array):void
   {

      //O filter input
      //O var cutname:String = String(flist[0].input.text);
      var cutname:String = String(flist[0].input.text);
      //O var tooldiameter:Number = Math.abs(Number(flist[1].input.text));
      var tooldiameter:number = Math.abs(Number(flist[1].input.text));
      //O var targetdepth:Number = Number(flist[2].input.text);
      var targetdepth:number = Number(flist[2].input.text);
      //O var safetyheight:Number = Number(flist[3].input.text);
      var safetyheight:number = Number(flist[3].input.text);
      //O var stocksurface:Number = Number(flist[4].input.text);
      var stocksurface:number = Number(flist[4].input.text);
      //O var stepover:Number = 0.01*Math.abs(Number(flist[5].input.text));
      var stepover:number = 0.01*Math.abs(Number(flist[5].input.text));
      //O var stepdown:Number = Math.abs(Number(flist[6].input.text));
      var stepdown:number = Math.abs(Number(flist[6].input.text));
      //O var roughingclearance:Number = Math.abs(Number(flist[7].input.text));
      var roughingclearance:number = Math.abs(Number(flist[7].input.text));
      //O var feedrate:Number = Math.abs(Number(flist[8].input.text));
      var feedrate:number = Math.abs(Number(flist[8].input.text));
      //O var plungerate:Number = Math.abs(Number(flist[9].input.text));
      var plungerate:number = Math.abs(Number(flist[9].input.text));
      //O var dir:int = flist[10].input.selectedItem.data;
      var dir: number = flist[10].input.selectedItem.data;

      //O if (Global.unit == "cm")
      if (Global.unit == "cm")
      {
         //O internal units are cm whereas machining units are given in mm
         //O tooldiameter /= 10;
         tooldiameter /= 10;
         //O roughingclearance /= 10;
         roughingclearance /= 10;
      }

      //O var main:* = this.parent;
      var main:* = this.parent;
      //O var cut:PocketCutObject = main.tools.dToolpaths.selectedItem.data;
      var cut:PocketCutObject = main.tools.dToolpaths.selectedItem.data;

      //O var redrawcut:Boolean = false;
      var redrawcut:boolean = false;
      //O if (tooldiameter != cut.tooldiameter || roughingclearance != cut.roughingclearance || stepover != cut.stepover || dir != cut.dir)
      if (tooldiameter != cut.tooldiameter || roughingclearance != cut.roughingclearance || stepover != cut.stepover || dir != cut.dir)
      {
         //O redrawcut = true;
         redrawcut = true;
      }

      //O cut.name = cutname;
      cut.name = cutname;
      //O main.tools.dToolpaths.selectedItem.label = cutname;
      main.tools.dToolpaths.selectedItem.label = cutname;
      //O cut.safetyheight = isNaN(safetyheight) ? cut.safetyheight : safetyheight;
      cut.safetyheight = isNaN(safetyheight) ? cut.safetyheight : safetyheight;
      //O cut.stocksurface = isNaN(stocksurface) ? cut.stocksurface : stocksurface;
      cut.stocksurface = isNaN(stocksurface) ? cut.stocksurface : stocksurface;
      //O cut.targetdepth = isNaN(targetdepth) ? cut.targetdepth : targetdepth;
      cut.targetdepth = isNaN(targetdepth) ? cut.targetdepth : targetdepth;
      //O cut.tooldiameter = (isNaN(tooldiameter) || tooldiameter == 0) ? cut.tooldiameter : tooldiameter;
      cut.tooldiameter = (isNaN(tooldiameter) || tooldiameter == 0) ? cut.tooldiameter : tooldiameter;
      //O cut.stepover = (isNaN(stepover) || stepover == 0) ? cut.stepover : stepover;
      cut.stepover = (isNaN(stepover) || stepover == 0) ? cut.stepover : stepover;
      //O cut.stepdown = (isNaN(stepdown) || stepdown == 0) ? cut.stepdown : stepdown;
      cut.stepdown = (isNaN(stepdown) || stepdown == 0) ? cut.stepdown : stepdown;
      //O cut.roughingclearance = isNaN(roughingclearance) ? cut.roughingclearance : roughingclearance;
      cut.roughingclearance = isNaN(roughingclearance) ? cut.roughingclearance : roughingclearance;
      //O cut.feedrate = (isNaN(feedrate) || feedrate == 0) ? cut.feedrate : feedrate;
      cut.feedrate = (isNaN(feedrate) || feedrate == 0) ? cut.feedrate : feedrate;
      //O cut.plungerate = (isNaN(plungerate) || plungerate == 0) ? cut.plungerate : plungerate;
      cut.plungerate = (isNaN(plungerate) || plungerate == 0) ? cut.plungerate : plungerate;
      //O cut.dir = dir;
      cut.dir = dir;

      //O if (redrawcut)
      if (redrawcut)
      {
         //O cut.pathlist[0].dirty = true;
         cut.pathlist[0].dirty = true;
         //O cut.pathlist[0].camdirty = true;
         cut.pathlist[0].camdirty = true;
         //O cut.processed = false;
         cut.processed = false;
         //O redraw();
         redraw();
      }
   }

   //O public function followpath(flist:Array):void
   public function followpath(flist:Array):void
   {

      //O filter input
      //O var cutname:String = String(flist[0].input.text);
      var cutname:String = String(flist[0].input.text);
      //O var tooldiameter:Number = Math.abs(Number(flist[1].input.text));
      var tooldiameter:number = Math.abs(Number(flist[1].input.text));
      //O var targetdepth:Number = Number(flist[2].input.text);
      var targetdepth:number = Number(flist[2].input.text);
      //O var safetyheight:Number = Number(flist[3].input.text);
      var safetyheight:number = Number(flist[3].input.text);
      //O var stocksurface:Number = Number(flist[4].input.text);
      var stocksurface:number = Number(flist[4].input.text);
      //O var stepdown:Number = Math.abs(Number(flist[5].input.text));
      var stepdown:number = Math.abs(Number(flist[5].input.text));
      //O var feedrate:Number = Math.abs(Number(flist[6].input.text));
      var feedrate:number = Math.abs(Number(flist[6].input.text));
      //O var plungerate:Number = Math.abs(Number(flist[7].input.text));
      var plungerate:number = Math.abs(Number(flist[7].input.text));

      //O if (isNaN(tooldiameter) || isNaN(safetyheight) || isNaN(stocksurface) || isNaN(targetdepth) || isNaN(stepdown) || stepdown == 0 || isNaN(feedrate) || feedrate == 0 || isNaN(plungerate) || plungerate == 0)
      if (isNaN(tooldiameter) || isNaN(safetyheight) || isNaN(stocksurface) || isNaN(targetdepth) || isNaN(stepdown) || stepdown == 0 || isNaN(feedrate) || feedrate == 0 || isNaN(plungerate) || plungerate == 0)
      {
         //O return;
         return;
      }

      //O if (Global.unit == "cm")
      if (Global.unit == "cm")
      {
         //O internal units are cm whereas machining units are given in mm
         //O tooldiameter /= 10;
         tooldiameter /= 10;
      }

      //O var selectedpaths:Array = new Array();
      var selectedpaths:Array = new Array();
      //O for(var i:int=0; i<pathlist.length; i++)
      for(let i=0; i<pathlist.length; i++)
      {
         //O if (pathlist[i].active == true)
         if (pathlist[i].active == true)
         {
            //O selectedpaths.push(pathlist[i]);
            selectedpaths.push(pathlist[i]);
         }
      }

      //O var cut:FollowPathCutObject = new FollowPathCutObject();
      var cut:FollowPathCutObject = new FollowPathCutObject();

      //O cut.name = cutname;
      cut.name = cutname;
      //O cut.tooldiameter = tooldiameter;
      cut.tooldiameter = tooldiameter;
      //O cut.targetdepth = targetdepth;
      cut.targetdepth = targetdepth;
      //O cut.safetyheight = safetyheight;
      cut.safetyheight = safetyheight;
      //O cut.stocksurface = stocksurface;
      cut.stocksurface = stocksurface;
      //O cut.stepdown = stepdown;
      cut.stepdown = stepdown;
      //O cut.feedrate = feedrate;
      cut.feedrate = feedrate;
      //O cut.plungerate = plungerate;
      cut.plungerate = plungerate;

      //O cut.pathlist = selectedpaths;
      cut.pathlist = selectedpaths;

      //O addCut(cut);
      addCut(cut);

      /*
//O      var result:Array = cut.process(selectedpaths);
//O
//O      if (result == null || result.length == 0){
//O         removeChild(cut);
//O         cutlist.splice(cutlist.indexOf(cut),1);
//O      }
      */

      //O redraw();
      redraw();
   }

   //O public function editfollowpath(flist:Array):void
   public function editfollowpath(flist:Array):void
   {

      //O filter input
      //O var cutname:String = String(flist[0].input.text);
      var cutname:String = String(flist[0].input.text);
      //O var tooldiameter:Number = Math.abs(Number(flist[1].input.text));
      var tooldiameter:number = Math.abs(Number(flist[1].input.text));
      //O var targetdepth:Number = Number(flist[2].input.text);
      var targetdepth:number = Number(flist[2].input.text);
      //O var safetyheight:Number = Number(flist[3].input.text);
      var safetyheight:number = Number(flist[3].input.text);
      //O var stocksurface:Number = Number(flist[4].input.text);
      var stocksurface:number = Number(flist[4].input.text);
      //O var stepdown:Number = Math.abs(Number(flist[5].input.text));
      var stepdown:number = Math.abs(Number(flist[5].input.text));
      //O var feedrate:Number = Math.abs(Number(flist[6].input.text));
      var feedrate:number = Math.abs(Number(flist[6].input.text));
      //O var plungerate:Number = Math.abs(Number(flist[7].input.text));
      var plungerate:number = Math.abs(Number(flist[7].input.text));

      //O if (Global.unit == "cm")
      if (Global.unit == "cm")
      {
         //O internal units are cm whereas machining units are given in mm
         //O tooldiameter /= 10;
         tooldiameter /= 10;
      }

      //O var main:* = this.parent;
      var main:* = this.parent;
      //O var cut:FollowPathCutObject = main.tools.dToolpaths.selectedItem.data;
      var cut:FollowPathCutObject = main.tools.dToolpaths.selectedItem.data;

      //O cut.name = cutname;
      cut.name = cutname;
      //O main.tools.dToolpaths.selectedItem.label = cutname;
      main.tools.dToolpaths.selectedItem.label = cutname;
      //O cut.tooldiameter = (isNaN(tooldiameter) || tooldiameter == 0) ? cut.tooldiameter : tooldiameter;
      cut.tooldiameter = (isNaN(tooldiameter) || tooldiameter == 0) ? cut.tooldiameter : tooldiameter;
      //O cut.safetyheight = isNaN(safetyheight) ? cut.safetyheight : safetyheight;
      cut.safetyheight = isNaN(safetyheight) ? cut.safetyheight : safetyheight;
      //O cut.stocksurface = isNaN(stocksurface) ? cut.stocksurface : stocksurface;
      cut.stocksurface = isNaN(stocksurface) ? cut.stocksurface : stocksurface;
      //O cut.targetdepth = isNaN(targetdepth) ? cut.targetdepth : targetdepth;
      cut.targetdepth = isNaN(targetdepth) ? cut.targetdepth : targetdepth;
      //O cut.stepdown = (isNaN(stepdown) || stepdown == 0) ? cut.stepdown : stepdown;
      cut.stepdown = (isNaN(stepdown) || stepdown == 0) ? cut.stepdown : stepdown;
      //O cut.feedrate = (isNaN(feedrate) || feedrate == 0) ? cut.feedrate : feedrate;
      cut.feedrate = (isNaN(feedrate) || feedrate == 0) ? cut.feedrate : feedrate;
      //O cut.plungerate = (isNaN(plungerate) || plungerate == 0) ? cut.plungerate : plungerate;
      cut.plungerate = (isNaN(plungerate) || plungerate == 0) ? cut.plungerate : plungerate;

      //O redraw();
      redraw();
   }

   //O public function drill(flist:Array):void
   public function drill(flist:Array):void
   {
      //O filter input
      //O var cutname:String = String(flist[0].input.text);
      var cutname:String = String(flist[0].input.text);
      //O var tooldiameter:Number = Math.abs(Number(flist[1].input.text));
      var tooldiameter:number = Math.abs(Number(flist[1].input.text));
      //O var targetdepth:Number = Number(flist[2].input.text);
      var targetdepth:number = Number(flist[2].input.text);
      //O var center:Boolean = flist[3].input.selectedItem.data;
      var center:boolean = flist[3].input.selectedItem.data;
      //O var spacing:Number = Number(flist[4].input.text);
      var spacing:number = Number(flist[4].input.text);
      //O var safetyheight:Number = Number(flist[5].input.text);
      var safetyheight:number = Number(flist[5].input.text);
      //O var stocksurface:Number = Number(flist[6].input.text);
      var stocksurface:number = Number(flist[6].input.text);
      //O var stepdown:Number = Math.abs(Number(flist[7].input.text));
      var stepdown:number = Math.abs(Number(flist[7].input.text));
      //O var plungerate:Number = Math.abs(Number(flist[8].input.text));
      var plungerate:number = Math.abs(Number(flist[8].input.text));

      //O if (isNaN(tooldiameter) || isNaN(safetyheight) || isNaN(stocksurface) || isNaN(targetdepth) || isNaN(stepdown) || stepdown == 0 || isNaN(plungerate) || plungerate == 0 || isNaN(spacing) || spacing == 0)
      if (isNaN(tooldiameter) || isNaN(safetyheight) || isNaN(stocksurface) || isNaN(targetdepth) || isNaN(stepdown) || stepdown == 0 || isNaN(plungerate) || plungerate == 0 || isNaN(spacing) || spacing == 0)
      {
         //O return;
         return;
      }

      //O if (Global.unit == "cm")
      if (Global.unit == "cm")
      {
         //O internal units are cm whereas machining units are given in mm
         //O tooldiameter /= 10;
         tooldiameter /= 10;
         //O spacing /= 10;
         spacing /= 10;
      }

      //O var selectedpaths:Array = new Array();
      var selectedpaths:Array = new Array();
      //O for(var i:int=0; i<pathlist.length; i++)
      for(let i=0; i<pathlist.length; i++) 
      {
         //O if (pathlist[i].active == true)
         if (pathlist[i].active == true) 
         {
            //O selectedpaths.push(pathlist[i]);
            selectedpaths.push(pathlist[i]);
         }
      }

      //O var cut:DrillCutObject = new DrillCutObject();
      var cut:DrillCutObject = new DrillCutObject();

      //O cut.name = cutname;
      cut.name = cutname;
      //O cut.tooldiameter = tooldiameter;
      cut.tooldiameter = tooldiameter;
      //O cut.targetdepth = targetdepth;
      cut.targetdepth = targetdepth;
      //O cut.center = center;
      cut.center = center;
      //O cut.spacing = spacing;
      cut.spacing = spacing;
      //O cut.safetyheight = safetyheight;
      cut.safetyheight = safetyheight;
      //O cut.stocksurface = stocksurface;
      cut.stocksurface = stocksurface;
      //O cut.stepdown = stepdown;
      cut.stepdown = stepdown;
      //O cut.plungerate = plungerate;
      cut.plungerate = plungerate;

      //O cut.pathlist = selectedpaths;
      cut.pathlist = selectedpaths;

      //O addCut(cut);
      addCut(cut);

      /*
//O      var result:Array = cut.process(selectedpaths);
//O
//O      if (result == null || result.length == 0){
//O         removeChild(cut);
//O         cutlist.splice(cutlist.indexOf(cut),1);
//O      }
      */

      //O redraw();
      redraw();
   }

   //O public function editdrill(flist:Array):void
   public function editdrill(flist:Array):void
   {
      //O filter input
      //O var cutname:String = String(flist[0].input.text);
      var cutname:String = String(flist[0].input.text);
      //O var tooldiameter:Number = Math.abs(Number(flist[1].input.text));
      var tooldiameter:number = Math.abs(Number(flist[1].input.text));
      //O var targetdepth:Number = Number(flist[2].input.text);
      var targetdepth:number = Number(flist[2].input.text);
      //O var center:Boolean = flist[3].input.selectedItem.data;
      var center:boolean = flist[3].input.selectedItem.data;
      //O var spacing:Number = Number(flist[4].input.text);
      var spacing:number = Number(flist[4].input.text);
      //O var safetyheight:Number = Number(flist[5].input.text);
      var safetyheight:number = Number(flist[5].input.text);
      //O var stocksurface:Number = Number(flist[6].input.text);
      var stocksurface:number = Number(flist[6].input.text);
      //O var stepdown:Number = Math.abs(Number(flist[7].input.text));
      var stepdown:number = Math.abs(Number(flist[7].input.text));
      //O var plungerate:Number = Math.abs(Number(flist[8].input.text));
      var plungerate:number = Math.abs(Number(flist[8].input.text));

      //O if (Global.unit == "cm")
      if (Global.unit == "cm")
      {
         //O internal units are cm whereas machining units are given in mm
         //O tooldiameter /= 10;
         tooldiameter /= 10;
         //O spacing /= 10;
         spacing /= 10;
      }

      //O var main:* = this.parent;
      var main:* = this.parent;
      //O var cut:DrillCutObject = main.tools.dToolpaths.selectedItem.data;
      var cut:DrillCutObject = main.tools.dToolpaths.selectedItem.data;

      //O var redrawcut:Boolean = false;
      var redrawcut:boolean = false;
      //O if (center != cut.center)
      if (center != cut.center)
      {
         //O redrawcut = true;
         redrawcut = true;
      }

      //O cut.name = cutname;
      cut.name = cutname;
      //O main.tools.dToolpaths.selectedItem.label = cutname;
      main.tools.dToolpaths.selectedItem.label = cutname;
      //O cut.tooldiameter = (isNaN(tooldiameter) || tooldiameter == 0) ? cut.tooldiameter : tooldiameter;
      cut.tooldiameter = (isNaN(tooldiameter) || tooldiameter == 0) ? cut.tooldiameter : tooldiameter;
      //O cut.center = center;
      cut.center = center;
      //O cut.spacing = (isNaN(spacing) || spacing == 0) ? cut.spacing : spacing;
      cut.spacing = (isNaN(spacing) || spacing == 0) ? cut.spacing : spacing;
      //O cut.safetyheight = isNaN(safetyheight) ? cut.safetyheight : safetyheight;
      cut.safetyheight = isNaN(safetyheight) ? cut.safetyheight : safetyheight;
      //O cut.stocksurface = isNaN(stocksurface) ? cut.stocksurface : stocksurface;
      cut.stocksurface = isNaN(stocksurface) ? cut.stocksurface : stocksurface;
      //O cut.targetdepth = isNaN(targetdepth) ? cut.targetdepth : targetdepth;
      cut.targetdepth = isNaN(targetdepth) ? cut.targetdepth : targetdepth;
      //O cut.stepdown = (isNaN(stepdown) || stepdown == 0) ? cut.stepdown : stepdown;
      cut.stepdown = (isNaN(stepdown) || stepdown == 0) ? cut.stepdown : stepdown;
      //O cut.plungerate = (isNaN(plungerate) || plungerate == 0) ? cut.plungerate : plungerate;
      cut.plungerate = (isNaN(plungerate) || plungerate == 0) ? cut.plungerate : plungerate;

      //O if (redrawcut)
      if (redrawcut)
      {
         //O cut.pathlist[0].dirty = true;
         cut.pathlist[0].dirty = true;
         //O cut.pathlist[0].camdirty = true;
         cut.pathlist[0].camdirty = true;
         //O cut.processed = false;
         cut.processed = false;
      }

      //O redraw();
      redraw();
   }

   //O public function batch(flist:Array):void
   public function batch(flist:Array):void
   {
      //O filter input
      //O var tooldiameter:Number = Math.abs(Number(flist[0].input.text));
      var tooldiameter:number = Math.abs(Number(flist[0].input.text));
      //O var targetdepth:Number = Number(flist[1].input.text);
      var targetdepth:number = Number(flist[1].input.text);
      //O var outside:Boolean = flist[2].input.selectedItem.data;
      var outside:boolean = flist[2].input.selectedItem.data;
      //O var safetyheight:Number = Number(flist[3].input.text);
      var safetyheight:number = Number(flist[3].input.text);
      //O var stocksurface:Number = Number(flist[4].input.text);
      var stocksurface:number = Number(flist[4].input.text);
      //O var stepover:Number = 0.01*Math.abs(Number(flist[5].input.text));
      var stepover:number = 0.01*Math.abs(Number(flist[5].input.text));
      //O var stepdown:Number = Math.abs(Number(flist[6].input.text));
      var stepdown:number = Math.abs(Number(flist[6].input.text));
      //O var roughingclearance:Number = Math.abs(Number(flist[7].input.text));
      var roughingclearance:number = Math.abs(Number(flist[7].input.text));
      //O var feedrate:Number = Math.abs(Number(flist[8].input.text));
      var feedrate:number = Math.abs(Number(flist[8].input.text));
      //O var plungerate:Number = Math.abs(Number(flist[9].input.text));
      var plungerate:number = Math.abs(Number(flist[9].input.text));
      //O var dir:int = flist[10].input.selectedItem.data;
      var dir: number = flist[10].input.selectedItem.data;
      //O var center:Boolean = flist[11].input.selectedItem.data;
      var center:boolean = flist[11].input.selectedItem.data;
      //O var spacing:Number = Number(flist[12].input.text);
      var spacing:number = Number(flist[12].input.text);

      //O if (Global.unit == "cm")
      if (Global.unit == "cm")
      {
         //O internal units are cm whereas machining units are given in mm
         //O tooldiameter /= 10;
         tooldiameter /= 10;
         //O roughingclearance /= 10;
         roughingclearance /= 10;
      }

      //O if (isNaN(safetyheight) || isNaN(stocksurface) || isNaN(targetdepth) || isNaN(tooldiameter) || isNaN(stepdown) || stepdown == 0 || isNaN(feedrate) || feedrate == 0 || isNaN(plungerate) || plungerate == 0)
      if (isNaN(safetyheight) || isNaN(stocksurface) || isNaN(targetdepth) || isNaN(tooldiameter) || isNaN(stepdown) || stepdown == 0 || isNaN(feedrate) || feedrate == 0 || isNaN(plungerate) || plungerate == 0)
      {
         //O return;
         return;
      }

      //O var selectedcuts:Array = new Array();
      var selectedcuts:Array = new Array();
      //O for(var i:int=0; i<cutlist.length; i++)
      for(let i=0; i<this.cutlist.length; i++)
      {
         //O if (cutlist[i].active == true)
         if (this.cutlist[i].active == true)
         {
            //O selectedcuts.push(cutlist[i]);
            selectedcuts.push(this.cutlist[i]);
         }
      }

      //O for each(var cut:* in selectedcuts)
      for each(var cut:* in selectedcuts)
      {
         //O cut.pathlist[0].dirty = true;
         cut.pathlist[0].dirty = true;
         //O cut.pathlist[0].camdirty = true;
         cut.pathlist[0].camdirty = true;
         //O cut.processed = false;
         cut.processed = false;

         //O cut.safetyheight = safetyheight;
         cut.safetyheight = safetyheight;
         //O cut.stocksurface = stocksurface;
         cut.stocksurface = stocksurface;
         //O cut.outside = outside;
         cut.outside = outside;
         //O cut.targetdepth = targetdepth;
         cut.targetdepth = targetdepth;
         //O cut.tooldiameter = tooldiameter;
         cut.tooldiameter = tooldiameter;
         //O cut.stepover = stepover;
         cut.stepover = stepover;
         //O cut.stepdown = stepdown;
         cut.stepdown = stepdown;
         //O cut.roughingclearance = roughingclearance;
         cut.roughingclearance = roughingclearance;
         //O cut.feedrate = feedrate;
         cut.feedrate = feedrate;
         //O cut.plungerate = plungerate;
         cut.plungerate = plungerate;
         //O cut.dir = dir;
         cut.dir = dir;

         //O cut.center = center;
         cut.center = center;
         //O cut.spacing = spacing;
         cut.spacing = spacing;
      }

      //O redraw();
      redraw();
   }

   //O public function zeroSelected():void
   public function zeroSelected():void
   {
      //O for(var i:int=0; i<pathlist.length; i++)
      for(let i=0; i<pathlist.length; i++)
      {
         //O if (pathlist[i].active == true)
         if (pathlist[i].active == true)
         {
            //O pathlist[i].zeroOrigin();
            pathlist[i].zeroOrigin();
         }
      }
   }

   //O public function getProcessedCuts():Array
   public function getProcessedCuts():Array
   {
      //O var processed:Array = new Array();
      var processed:Array = new Array();
      //O for(var i:int=0; i<cutlist.length; i++)
      for(let i=0; i<this.cutlist.length; i++)
      {
         //O if (cutlist[i].processed == true)
         if (this.cutlist[i].processed == true) 
         {
            //O processed.push(cutlist[i]);
            processed.push(this.cutlist[i]);
         }
      }

      //O return processed;
      return processed;
   }

   //O public function addCut(cut:CutObject):void
   public function addCut(cut:CutObject):void
   {
      //O var cutgroup:Array = new Array(cut);
      var cutgroup:Array = new Array(cut);

      //O if (Global.separatetoolpaths)
      if (Global.separatetoolpaths)
      {
         //O cutgroup = cut.group();
         cutgroup = cut.group();
      }

      //O for each(cut in cutgroup)
      for each(cut in cutgroup)
      {
         //O cutlist.push(cut);
         this.cutlist.push(cut);
         //O addChild(cut);
         addChild(cut);

         //O all paths of the cutobject are dirty to start with
         //O for each(var path:Path in cut.pathlist)
         for each(var path:Path in cut.pathlist)
         {
            //O path.dirty = true;
            path.dirty = true;
            //O path.camdirty = true;
            path.camdirty = true;
         }

         //O var main:* = this.parent;
         var main:* = this.parent;
         //O main.tools.dToolpaths.addItem({label: cut.name, data: cut});
         main.tools.dToolpaths.addItem({label: cut.name, data: cut});
         //O main.tools.dToolpaths.height = Math.max(cutlist.length*20,20);
         main.tools.dToolpaths.height = Math.max(this.cutlist.length*20,20);
         //O cut.setActive();
         cut.setActive();
      }
   }

   //O public function removeCut(cut:CutObject):Boolean
   public function removeCut(cut:CutObject):boolean
   {
      //O if (cut == null)
      if (cut == null)
      {
         //O return false;
         return false;
      }
      //O if (this.contains(cut))
      if (this.contains(cut))
      {
         //O removeChild(cut);
         removeChild(cut);
      }
      //O var index:int = cutlist.indexOf(cut);
      var index: number = this.cutlist.indexOf(cut);
      //O if (index != -1)
      if (index != -1)
      {
         //O cutlist.splice(index,1);
         this.cutlist.splice(index,1);
         //O var main:* = this.parent;
         var main:* = this.parent;
         //O main.tools.dToolpaths.removeItemAt(index);
         main.tools.dToolpaths.removeItemAt(index);
         //O main.tools.dToolpaths.height = Math.max(cutlist.length*20,20);
         main.tools.dToolpaths.height = Math.max(this.cutlist.length*20,20);
         //O return true;
         return true;
      } else
      {
         //O return false;
         return false;
      }
   }

   //O public function reprocessCuts(pd:ProgressDialog, activeonly:Boolean = false, cut:CutObject=null):void
   public function reprocessCuts(pd:ProgressDialog, activeonly:boolean = false, cut:CutObject=null):void
   {
      //O progressdialog = pd;
      progressdialog = pd;
      //O processlist = new Array();
      processlist = new Array();

      //O if (cut != null)
      if (cut != null)
      {
         //O processlist.push(cut);
         processlist.push(cut);
      } else
      {
         //O for each(var cut:CutObject in cutlist)
         for each(var cut:CutObject in this.cutlist)
         {
            //O if (activeonly && cut.active == false)
            if (activeonly && cut.active == false)
            {
               //O continue;
               continue;
            }
            //O var reprocess:Boolean = false;
            var reprocess:boolean = false;
            //O for each(var path:Path in cut.pathlist)
            for each(var path:Path in cut.pathlist)
            {
               //O path.zeroOrigin();
               path.zeroOrigin();
               //O path.redraw();
               path.redraw();
               //O if (path.camdirty == true)
               if (path.camdirty == true)
               {
                  //O path.camdirty = false;
                  path.camdirty = false;
                  //O reprocess = true;
                  reprocess = true;
               }
            }
            //O if (reprocess || cut.processed == false)
            if (reprocess || cut.processed == false)
            {
               //O processlist.push(cut);
               processlist.push(cut);
            }
         }
      }

      //O progressdialog.init(processlist.length);
      progressdialog.init(processlist.length);

      //O processNext();
      processNext();

      //O redraw();
      redraw();
   }

   //O protected function processNext():void
   protected function processNext():void
   {
      //O if (processlist.length > 0)
      if (processlist.length > 0)
      {
         //O var cut:CutObject = processlist[0];
         var cut:CutObject = processlist[0];
         //O cut.addEventListener(ProgressEvent.PROGRESS, cutProgress);
         cut.addEventListener(ProgressEvent.PROGRESS, cutProgress);
         //O cut.addEventListener(Event.COMPLETE, cutComplete);
         cut.addEventListener(Event.COMPLETE, cutComplete);
         //O cut.start();
         cut.start();
         //O //processlist.shift();
         //processlist.shift();
      } else
      {
         //O cleanup
         //O progressdialog.stopDialog();
         progressdialog.stopDialog();
      }
   }

   //O protected function cutProgress(e:ProgressEvent):void
   protected function cutProgress(e:ProgressEvent):void
   {
      //O var cutprogress:Number = Math.min(e.bytesLoaded/e.bytesTotal,1);
      var cutprogress:number = Math.min(e.bytesLoaded/e.bytesTotal,1);
      //O var totalprogress:Number = progressdialog.total - processlist.length + cutprogress;
      var totalprogress:number = progressdialog.total - processlist.length + cutprogress;
      //O progressdialog.setProgress(totalprogress);
      progressdialog.setProgress(totalprogress);
   }

   //O protected function cutComplete(e:Event)
   protected function cutComplete(e:Event)
   {
      //O if (e.target is CutObject)
      if (e.target is CutObject)
      {
         //O var cut:CutObject = e.target as CutObject;
         var cut:CutObject = e.target as CutObject;
         //O cut.removeEventListener(ProgressEvent.PROGRESS, cutProgress);
         cut.removeEventListener(ProgressEvent.PROGRESS, cutProgress);
         //O cut.removeEventListener(Event.COMPLETE, cutComplete);
         cut.removeEventListener(Event.COMPLETE, cutComplete);

         //O if (processlist.length > 0)
         if (processlist.length > 0)
         {
            //O processlist.shift();
            processlist.shift();
         }

         //O processNext();
         processNext();
      }
   }

   //O public function cutCancel():void
   public function cutCancel():void
   {
      //O var main:* = this.parent;
      var main:* = this.parent;

      //O if (processlist.length > 0)
      if (processlist.length > 0)
      {
         //O var current:CutObject = processlist.shift();
         var current:CutObject = processlist.shift();
         //O current.stop();
         current.stop();
         //O current.processed = false;
         current.processed = false;
      }

      //O current.pathlist[0].dirty = true;
      current.pathlist[0].dirty = true;
      //O current.pathlist[0].camdirty = true;
      current.pathlist[0].camdirty = true;

      //O processlist = new Array();
      processlist = new Array();
   }

   //O public function processFile(pd:ProgressDialog, svgxml:XML):void
   public function processFile(pd:ProgressDialog, svgxml:XML):void
   {
      //O progressdialog = pd;
      progressdialog = pd;
      //O pd.init(1);
      pd.init(1);

      //O var processor:ProcessFile = new ProcessFile(this,pathlist,svgxml);
      var processor:ProcessFile = new ProcessFile(this,pathlist,svgxml);
      //O processor.addEventListener(ProgressEvent.PROGRESS, processProgress);
      processor.addEventListener(ProgressEvent.PROGRESS, processProgress);
      //O processor.addEventListener(Event.COMPLETE, processComplete);
      processor.addEventListener(Event.COMPLETE, processComplete);
      //O addChild(processor);
      addChild(processor);
      //O processor.start();
      processor.start();
   }

   //O public function processProgress(e:ProgressEvent):void
   public function processProgress(e:ProgressEvent):void
   {
      //O progressdialog.setProgress(e.bytesLoaded/e.bytesTotal);
      progressdialog.setProgress(e.bytesLoaded/e.bytesTotal);
   }

   //O public function processComplete(e:Event):void
   public function processComplete(e:Event):void
   {
      //O for each(var path:Path in pathlist)
      for each(var path:Path in pathlist)
      {
         //O check for self-overlap (beginning and end points are within tolerances)
         //O if (path.active == true)
         if (path.active == true)
         {
            //O if (Global.withinTolerance(path.seglist[0].p1,path.seglist[path.seglist.length-1].p2))
            if (Global.withinTolerance(path.seglist[0].p1,path.seglist[path.seglist.length-1].p2))
            {
               //O path.seglist[0].p1 = path.seglist[path.seglist.length-1].p2;
               path.seglist[0].p1 = path.seglist[path.seglist.length-1].p2;
            }
         }
      }

      //O var processor:ProcessFile = e.target as ProcessFile;
      var processor:ProcessFile = e.target as ProcessFile;
      //O processor.removeEventListener(ProgressEvent.PROGRESS, processProgress);
      processor.removeEventListener(ProgressEvent.PROGRESS, processProgress);
      //O processor.removeEventListener(Event.COMPLETE, processComplete);
      processor.removeEventListener(Event.COMPLETE, processComplete);

      //O loadCuts(processor.svgxml);
      loadCuts(processor.svgxml);

      //O progressdialog.stopDialog();
      progressdialog.stopDialog();
      //O removeChild(processor);
      removeChild(processor);

      //O redraw();
      redraw();
   }

   //O add cutobjects from the raw svg xml file
   //O public function loadCuts(svg:XML):void
   public function loadCuts(svg:XML):void
   {
      //O var metadata:XML;
      var metadata:XML;

      //O for each(var child:XML in svg.*)
      for each(var child:XML in svg.*)
      {
         //O if (child.localName() == "metadata")
         if (child.localName() == "metadata")
         {
            //O metadata = child;
            metadata = child;
         }
      }

      //O if (metadata == null)
      if (metadata == null)
      {
         //O return;
         return;
      }

      //O for each(child in metadata.*)
      for each(child in metadata.*)
      {
         //O if (child.localName() == "cutobject")
         if (child.localName() == "cutobject")
         {
            //O loadCutObject(child);
            loadCutObject(child);
         }
      }

      //O // remove path names after they have been used (they will interfere with future load operations)
      // remove path names after they have been used (they will interfere with future load operations)
      //O for each(var path:Path in pathlist)
      for each(var path:Path in pathlist)
      {
         //O path.name = '';
         path.name = '';
      }
   }

   //O protected function loadCutObject(cutobject:XML):void
   protected function loadCutObject(cutobject:XML):void
   {
      //O var children:Array = new Array();
      var children:Array = new Array();

      //O // parse children first
      // parse children first

      //O for each(var child:XML in cutobject.*)
      for each(var child:XML in cutobject.*)
      {
         //O if (child.localName() == "path")
         if (child.localName() == "path")
         {
            //O var id:String = String(child.text());
            var id:String = String(child.text());
            //O for each(var path:Path in pathlist)
            for each(var path:Path in pathlist)
            {
               //O if (path.name == id)
               if (path.name == id)
               {
                  //O children.push(path);
                  children.push(path);
               }
            }
         }
      }

      //O if (children.length == 0)
      if (children.length == 0)
      {
         //O return;
         return;
      }

      //O var cut:CutObject;
      var cut:CutObject;
      //O var type:String = cutobject.@type;
      var type:String = cutobject.@type;

      //O if (type == "profile")
      if (type == "profile")
      {
         //O cut = new ProfileCutObject();
         cut = new ProfileCutObject();
      }
      //O else if (type == "pocket")
      else if (type == "pocket")
      {
         //O cut = new PocketCutObject();
         cut = new PocketCutObject();
      }
      //O else if (type == "followpath")
      else if (type == "followpath")
      {
         //O cut = new FollowPathCutObject();
         cut = new FollowPathCutObject();
      }
      //O else if (type == "drill")
      else if (type == "drill")
      {
         //O cut = new DrillCutObject();
         cut = new DrillCutObject();
      }

      //O var cutname:String = unescape(cutobject.@name);
      var cutname:String = unescape(cutobject.@name);

      //O if (cutname == "")
      if (cutname == "")
      {
         //O cutname = "unnamed operation";
         cutname = "unnamed operation";
      }

      //O cut.name = cutname;
      cut.name = cutname;
      //O cut.safetyheight = cutobject.@safetyheight;
      cut.safetyheight = cutobject.@safetyheight;
      //O cut.stocksurface = cutobject.@stocksurface;
      cut.stocksurface = cutobject.@stocksurface;
      //O cut.targetdepth = cutobject.@targetdepth;
      cut.targetdepth = cutobject.@targetdepth;
      //O cut.stepover = cutobject.@stepover;
      cut.stepover = cutobject.@stepover;
      //O cut.stepdown = cutobject.@stepdown;
      cut.stepdown = cutobject.@stepdown;
      //O cut.feedrate = cutobject.@feedrate;
      cut.feedrate = cutobject.@feedrate;
      //O cut.plungerate = cutobject.@plungerate;
      cut.plungerate = cutobject.@plungerate;

      //O cut.outside = (cutobject.@outside == "true" ? true : false);
      cut.outside = (cutobject.@outside == "true" ? true : false);
      //O cut.dir = (cutobject.@direction == "2" ? 2 : 1);
      cut.dir = (cutobject.@direction == "2" ? 2 : 1);

      //O cut.center = (cutobject.@center == "true" ? true : false);
      cut.center = (cutobject.@center == "true" ? true : false);
      //O cut.spacing = cutobject.@spacing;
      cut.spacing = cutobject.@spacing;

      //O cut.tooldiameter = cutobject.@tooldiameter;
      cut.tooldiameter = cutobject.@tooldiameter;
      //O cut.roughingclearance = cutobject.@roughingclearance;
      cut.roughingclearance = cutobject.@roughingclearance;

      //O if (Global.unit == "in" && cutobject.@unit == "metric")
      if (Global.unit == "in" && cutobject.@unit == "metric")
      {
         //O // mm to inch
         // mm to inch
         //O cut.safetyheight /= 25.4;
         cut.safetyheight /= 25.4;
         //O cut.stocksurface /= 25.4;
         cut.stocksurface /= 25.4;
         //O cut.targetdepth /= 25.4;
         cut.targetdepth /= 25.4;
         //O cut.stepdown /= 25.4;
         cut.stepdown /= 25.4;
         //O cut.feedrate /= 25.4;
         cut.feedrate /= 25.4;
         //O cut.plungerate /= 25.4;
         cut.plungerate /= 25.4;

         //O // cm to inch
         // cm to inch
         //O cut.tooldiameter /= 2.54;
         cut.tooldiameter /= 2.54;
         //O cut.roughingclearance /= 2.54;
         cut.roughingclearance /= 2.54;

         //O cut.spacing /= 2.54;
         cut.spacing /= 2.54;
      }
      //O else if (Global.unit == "cm" && cutobject.@unit == "imperial")
      else if (Global.unit == "cm" && cutobject.@unit == "imperial")
      {
         //O // inch to mm
         // inch to mm
         //O cut.safetyheight *= 25.4;
         cut.safetyheight *= 25.4;
         //O cut.stocksurface *= 25.4;
         cut.stocksurface *= 25.4;
         //O cut.targetdepth *= 25.4;
         cut.targetdepth *= 25.4;
         //O cut.stepdown *= 25.4;
         cut.stepdown *= 25.4;
         //O cut.feedrate *= 25.4;
         cut.feedrate *= 25.4;
         //O cut.plungerate *= 25.4;
         cut.plungerate *= 25.4;

         //O // inch to cm
         // inch to cm
         //O cut.tooldiameter *= 2.54;
         cut.tooldiameter *= 2.54;
         //O cut.roughingclearance *= 2.54;
         cut.roughingclearance *= 2.54;

         //O cut.spacing *= 2.54;
         cut.spacing *= 2.54;
      }

      //O for each(path in children)
      for each(path in children)
      {
         //O path.zeroOrigin();
         path.zeroOrigin();
      }

      //O cut.pathlist = children;
      cut.pathlist = children;

      //O addCut(cut);
      addCut(cut);
   }

   //O // do a separate operation on each selected path
   // do a separate operation on each selected path
   //O public function separateSelected():void
   public function separateSelected():void
   {

      //O var len:int = pathlist.length;
      var len: number = pathlist.length;

      //O for(var i:int=0; i<len; i++)
      for(let i=0; i<len; i++)
      {
         //O if (pathlist[i].active == true)
         if (pathlist[i].active == true)
         {
            //O var paths:Array = pathlist[i].separate();
            var paths:Array = pathlist[i].separate();
            //O if (paths.length > 0)
            if (paths.length > 0)
            {
               //O check cutlist (we must replace the path in the cutobject)
               //O for(var j:int=0; j<cutlist.length; j++)
               for(let j=0; j<this.cutlist.length; j++)
               {
                  //O var index:int = cutlist.pathlist.indexOf(pathlist[i]);
                  var index: number = this.cutlist.pathlist.indexOf(pathlist[i]);
                  //O if (index != -1)
                  if (index != -1)
                  {
                     //O cutlist.pathlist.splice(index,1,paths);
                     this.cutlist.pathlist.splice(index,1,paths);
                  }
               }
               //O for each(var p:Path in paths)
               for each(var p:Path in paths)
               {
                  //O p.name = pathlist[i].name;
                  p.name = pathlist[i].name;
               }
               //O pathlist.splice(i,1);
               pathlist.splice(i,1);
               //O addPaths(paths);
               addPaths(paths);
               //O i--;
               i--;
               //O len--;
               len--;
            }
         }
      }
   }

   /*
//O    public function mergeSelected():void
//O    {
//O      for(var i:int=0; i<pathlist.length; i++){
//O         var path:Path = pathlist[i];
//O         // check for overlapping points between this and every other path
//O         for(var j:int = i+1; j<pathlist.length; j++){
//O            var path2:Path = pathlist[j];
//O            if (path != path2 && path.active == true && path2.active == true){
//O               if (Global.withinTolerance(path.seglist[0].p1,path2.seglist[0].p1,0.1)){
//O                  path.reversePath();
//O                  path.resetSegments();
//O                  path.mergePath(path2,path.seglist[path.seglist.length-1].p2,false);
//O                  j = i;
//O               }
//O               else if (Global.withinTolerance(path.seglist[0].p1,path2.seglist[path2.seglist.length-1].p2,0.1)){
//O                  path2.mergePath(path,path2.seglist[path2.seglist.length-1].p2,false);
//O                  i--;
//O                  break;
//O               }
//O               else if (Global.withinTolerance(path.seglist[path.seglist.length-1].p2,path2.seglist[0].p1,0.1)){
//O                  path.mergePath(path2,path.seglist[path.seglist.length-1].p2,false);
//O                  j = i;
//O               }
//O               else if (Global.withinTolerance(path.seglist[path.seglist.length-1].p2,path2.seglist[path2.seglist.length-1].p2,0.1)){
//O                  path2.reversePath();
//O                  path.mergePath(path2,path.seglist[path.seglist.length-1].p2,false);
//O                  j = i;
//O               }
//O            }
//O         }
//O      }
//O
//O      for each(path in pathlist){
//O         // first check for self-overlap (beginning and end points are within tolerances)
//O         if (path.active == true){
//O            if (Global.withinTolerance(path.seglist[0].p1,path.seglist[path.seglist.length-1].p2)){
//O               path.seglist[0].p1 = path.seglist[path.seglist.length-1].p2;
//O            }
//O            //path.joinDoubles(1, true);
//O         }
//O      }
//O   }
   */

   //O public function pathsOnTop():void
   public function pathsOnTop():void
   {
      //O for each(var path:Path in pathlist)
      for each(var path:Path in pathlist)
      {
         //O addChild(path);
         addChild(path);
      }
   }

   //O nesting functions start here
   //O public function startNest(pd:ProgressDialog, directions:int, gap:Number, group:Boolean, groupprofile:Boolean):Boolean
   public function startNest(pd:ProgressDialog, directions:int, gap:number, group:boolean, groupprofile:boolean):boolean
   {
      //O progressdialog = pd;
      progressdialog = pd;

      //O if (nestpath == null)
      if (nestpath == null)
      {
         //O return false;
         return false;
      }

      //O if (cutlist.length < 2)
      if (this.cutlist.length < 2)
      {
         //O return false;
         return false;
      }

      //O if (nest != null && contains(nest))
      if (nest != null && contains(nest))
      {
         //O removeChild(nest);
         removeChild(nest);
      }

      //O nest = new Nest(nestpath, cutlist.slice(), directions, gap, group, groupprofile);
      nest = new Nest(nestpath, this.cutlist.slice(), directions, gap, group, groupprofile);
      //O addChild(nest);
      addChild(nest);

      //O for(var i:int=0; i<cutlist.length; i++)
      for(let i=0; i<this.cutlist.length; i++)
      {
         //O addChild(cutlist[i]);
         addChild(this.cutlist[i]);
      }

      //O nest.addEventListener(ProgressEvent.PROGRESS, nestProgress);
      nest.addEventListener(ProgressEvent.PROGRESS, nestProgress);

      //O nest.start();
      nest.start();

      //O if (nest.underlimit == true)
      if (nest.underlimit == true)
      {
         //O finishNest();
         finishNest();
         //O return false;
         return false;
      }

      //O progressdialog.init(1);
      progressdialog.init(1);

      //O return true;
      return true;
   }

   //O private function nestProgress(e:ProgressEvent):void
   private function nestProgress(e:ProgressEvent):void
   {
      //O var nestprogress:Number = Math.min(e.bytesLoaded/e.bytesTotal,1);
      var nestprogress:number = Math.min(e.bytesLoaded/e.bytesTotal,1);
      //O progressdialog.setProgress(nestprogress);
      progressdialog.setProgress(nestprogress);
   }

   //O stop nest and apply transformations
   //O public function finishNest():void
   public function finishNest():void
   {
      //O nest.stop();
      nest.stop();
      //O nest.removeEventListener(ProgressEvent.PROGRESS, nestProgress);
      nest.removeEventListener(ProgressEvent.PROGRESS, nestProgress);

      //O var fittest:Individual = nest.fittest;
      var fittest:Individual = nest.fittest;

      //O if (fittest)
      if (fittest)
      {
         //O apply transformation
         //O var data:Array = fittest.data;
         var data:Array = fittest.data;

         //O var region:Rectangle = nest.blank.getBounds(nest);
         var region:Rectangle = nest.blank.getBounds(nest);

         //O var processed:Array = new Array();
         var processed:Array = new Array();

         //O for(var i:int=0; i<data.length; i++)
         for(let i=0; i<data.length; i++)
         {
            //O if (!data[i].failed)
            if (!data[i].failed)
            {
               //O var cutobject:* = nest.cutlist[data[i].index];
               var cutobject:* = nest.this.cutlist[data[i].index];

               //O // the clumped nest object (cutobject) is represented as a tree using the displayobject dom
               // the clumped nest object (cutobject) is represented as a tree using the displayobject dom
               //O // we have to flatten it into an array
               // we have to flatten it into an array
               //O var cutarray:Array = new Array(cutobject);
               var cutarray:Array = new Array(cutobject);
               //O var index:int = 0;
               var index: number = 0;
               //O while(index < cutarray.length)
               while(index < cutarray.length)
               {
                  //O while(cutarray[index].numChildren > 0)
                  while(cutarray[index].numChildren > 0)
                  {
                     //O var childobject:* = cutarray[index].getChildAt(0);
                     var childobject:* = cutarray[index].getChildAt(0);
                     //O if (childobject is CutObject)
                     if (childobject is CutObject)
                     {
                        //O cutarray.push(childobject);
                        cutarray.push(childobject);
                     }
                     //O cutarray[index].removeChildAt(0);
                     cutarray[index].removeChildAt(0);
                  }
                  //O index++;
                  index++;
               }

               //O // gather all associated paths, and ensure that there are no repeats
               // gather all associated paths, and ensure that there are no repeats
               //O var nestarray:Array = new Array();
               var nestarray:Array = new Array();

               //O for(var j:int=0; j<cutarray.length; j++)
               for(let j=0; j<cutarray.length; j++)
               {
                  //O for(var k:int=0; k<cutarray[j].pathlist.length; k++)
                  for(let k=0; k<cutarray[j].pathlist.length; k++)
                  {
                     //O if (nestarray.indexOf(cutarray[j].pathlist[k]) == -1 && processed.indexOf(cutarray[j].pathlist[k]) == -1)
                     if (nestarray.indexOf(cutarray[j].pathlist[k]) == -1 && processed.indexOf(cutarray[j].pathlist[k]) == -1)
                     {
                        //O nestarray.push(cutarray[j].pathlist[k]);
                        nestarray.push(cutarray[j].pathlist[k]);
                        //O processed.push(cutarray[j].pathlist[k]);
                        processed.push(cutarray[j].pathlist[k]);
                     }
                  }
               }

               //O apply a matrix transform to each path in nest array
               //O var matrix:Matrix = new Matrix();
               var matrix:Matrix = new Matrix();
               //O matrix.rotate(-data[i].rotation*(Math.PI/180));
               matrix.rotate(-data[i].rotation*(Math.PI/180));

               //O account for translation caused by rotation
               //O matrix.translate(-data[i].x/Global.zoom, data[i].y/Global.zoom);
               matrix.translate(-data[i].x/Global.zoom, data[i].y/Global.zoom);

               //O account for bounding box of blank
               //O matrix.translate(region.x/Global.zoom, -(region.y+region.height-1)/Global.zoom);
               matrix.translate(region.x/Global.zoom, -(region.y+region.height-1)/Global.zoom);

               //O position within blank
               //O matrix.translate(data[i].i/(Global.zoom*nest.scale), (-data[i].j+nest.blankbitmap.height)/(Global.zoom*nest.scale));
               matrix.translate(data[i].i/(Global.zoom*nest.scale), (-data[i].j+nest.blankbitmap.height)/(Global.zoom*nest.scale));
               //O for(j=0; j<nestarray.length; j++)
               for(j=0; j<nestarray.length; j++)
               {
                  //O nestarray[j].matrixTransform(matrix);
                  nestarray[j].matrixTransform(matrix);
               }
            }
         }
      }
      //O nest.finish();
      nest.finish();
      //O removeChild(nest);
      removeChild(nest);

      //O for(i=0; i<cutlist.length; i++)
      for(i=0; i<this.cutlist.length; i++)
      {
         //O while(cutlist[i].numChildren > 0)
         while(this.cutlist[i].numChildren > 0)
         {
            //O cutlist[i].removeChildAt(0);
            this.cutlist[i].removeChildAt(0);
         }
         //O addChild(cutlist[i]);
         addChild(this.cutlist[i]);

         /*
//o      cutlist[i].docx = 0;
//o      cutlist[i].docy = 0;
//o      cutlist[i].x = 0;
//o      cutlist[i].y = 0;
         */

         //O cutlist[i].processed = false;
         this.cutlist[i].processed = false;
         //O cutlist[i].rotation = 0;
         this.cutlist[i].rotation = 0;
         //O cutlist[i].pathlist[0].dirty = true;
         this.cutlist[i].pathlist[0].dirty = true;
         //O cutlist[i].pathlist[0].camdirty = true;
         this.cutlist[i].pathlist[0].camdirty = true;
         //O cutlist[i].graphics.clear();
         this.cutlist[i].graphics.clear();
      }

      //O redraw();
      redraw();
   }

   //O adds tabs to selected (and calculated) profile operations
   //O public function addTabsSelected(spacing:Number, tabwidth:Number, tabheight:Number):void
   public function addTabsSelected(spacing:number, tabwidth:number, tabheight:number):void
   {
      //O for(var i:int=0; i<cutlist.length; i++)
      for(let i=0; i<this.cutlist.length; i++)
      {
         //O if (cutlist[i].active == true && cutlist[i] is ProfileCutObject && cutlist[i].processed == true)
         if (this.cutlist[i].active == true && this.cutlist[i] is ProfileCutObject && this.cutlist[i].processed == true)
         {
            //O cutlist[i].addTabs(spacing, tabwidth, tabheight);
            this.cutlist[i].addTabs(spacing, tabwidth, tabheight);
         }
      }
   }

   //O move the selected cutobjects outside of the bounding box of the deselected cutobjects
   //O public function shiftActive():void
   public function shiftActive():void
   {
      //O var inactive:Array = new Array();
      var inactive:Array = new Array();
      //O var active:Array = new Array();
      var active:Array = new Array();

      //O for(var i:int = 0; i<cutlist.length; i++)
      for(let i = 0; i<this.cutlist.length; i++)
      {
         //O if (cutlist[i].active == true)
         if (this.cutlist[i].active == true)
         {
            //O active.push(cutlist[i]);
            active.push(this.cutlist[i]);
         } else
         {
            //O inactive.push(cutlist[i]);
            inactive.push(this.cutlist[i]);
         }
         //O some problems with accounting for docx/y, for now just reset all to zero
         //O cutlist[i].zeroOrigin();
         this.cutlist[i].zeroOrigin();
         //O cutlist[i].pathlist[0].dirty = true;
         this.cutlist[i].pathlist[0].dirty = true;
         //O cutlist[i].pathlist[0].camdirty = true;
         this.cutlist[i].pathlist[0].camdirty = true;
      }

      //O var irect:Rectangle = getExactBounds(inactive);
      var irect:Rectangle = getExactBounds(inactive);
      //O var arect:Rectangle = getExactBounds(active);
      var arect:Rectangle = getExactBounds(active);

      /*
//O      var p:Path = new Path();
//O      var seg1:Segment = new Segment(new Point(irect.x,irect.y),new Point(irect.x,irect.y+irect.height));
//O      var seg2:Segment = new Segment(seg1.p2,new Point(irect.x+irect.width,irect.y+irect.height));
//O      var seg3:Segment = new Segment(seg2.p2,new Point(irect.x+irect.width,irect.y));
//O      var seg4:Segment = new Segment(seg3.p2,new Point(irect.x,irect.y));
//O
//O      p.addSegment(seg1);
//O      p.addSegment(seg2);
//O      p.addSegment(seg3);
//O      p.addSegment(seg4);
//O
//O      addPath(p);
      */

      //O var diff:Number = 0;
      var diff:number = 0;

      //O if (arect.x >= irect.x && arect.x <= irect.x + irect.width)
      if (arect.x >= irect.x && arect.x <= irect.x + irect.width)
      {
         //O diff = irect.x + irect.width - arect.x;
         diff = irect.x + irect.width - arect.x;
      }
      //O else if (irect.x >= arect.x && irect.x <= arect.x + arect.width)
      else if (irect.x >= arect.x && irect.x <= arect.x + arect.width)
      {
         //O diff = arect.x + arect.width - irect.x;
         diff = arect.x + arect.width - irect.x;
         //O diff = -diff;
         diff = -diff;
      }

      //O var processed:Array = new Array();
      var processed:Array = new Array();

      //O for(i=0; i<active.length; i++)
      for(i=0; i<active.length; i++)
      {
         //O for(var j:int=0; j<active[i].pathlist.length; j++)
         for(let j=0; j<active[i].pathlist.length; j++)
         {
            //O var path:Path = active[i].pathlist[j];
            var path:Path = active[i].pathlist[j];
            //O if (processed.indexOf(path) == -1)
            if (processed.indexOf(path) == -1)
            {
               //O path.docx += diff;
               path.docx += diff;
               //O path.dirty = true;
               path.dirty = true;
               //O path.camdirty = true;
               path.camdirty = true;
               //O processed.push(path);
               processed.push(path);
            }
         }
      }

      //O redraw();
      redraw();
   }

   //O get exact bounds of the list of cutobjects, taking into account whether they are processed
   //O private function getExactBounds(list:Array):Rectangle
   private function getExactBounds(list:Array):Rectangle
   {
      //O var minx:Number;
      var minx:number;
      //O var miny:Number;
      var miny:number;
      //O var maxx:Number;
      var maxx:number;
      //O var maxy:Number;
      var maxy:number;

      //O find bounding box of deselected cutpaths
      //O for(var i:int=0; i<list.length; i++)
      for(let i=0; i<list.length; i++)
      {
         //O var lminx:Number = NaN;
         var lminx:number = NaN;
         //O var lminy:Number = NaN;
         var lminy:number = NaN;
         //O var lmaxx:Number = NaN;
         var lmaxx:number = NaN;
         //O var lmaxy:Number = NaN;
         var lmaxy:number = NaN;

         //O var children:Array = list[i].rootpath.getChildren();
         var children:Array = list[i].rootpath.getChildren();
         //O for(var j:int=0; j<children.length; j++)
         for(let j=0; j<children.length; j++)
         {
            //O var rect:Rectangle = children[j].getExactBounds();
            var rect:Rectangle = children[j].getExactBounds();
            //O if (isNaN(lminx) || rect.x < lminx)
            if (isNaN(lminx) || rect.x < lminx)
            {
               //O lminx = rect.x;
               lminx = rect.x;
            }
            //O if (isNaN(lmaxx) || rect.x + rect.width > lmaxx)
            if (isNaN(lmaxx) || rect.x + rect.width > lmaxx)
            {
               //O lmaxx = rect.x + rect.width;
               lmaxx = rect.x + rect.width;
            }
            //O if (isNaN(lminy) || rect.y < lminy)
            if (isNaN(lminy) || rect.y < lminy)
            {
               //O lminy = rect.y;
               lminy = rect.y;
            }
            //O if (isNaN(lmaxy) || rect.y + rect.height > lmaxy)
            if (isNaN(lmaxy) || rect.y + rect.height > lmaxy)
            {
               //O lmaxy = rect.y + rect.height;
               lmaxy = rect.y + rect.height;
            }
         }

         //O if (list[i] is ProfileCutObject)
         if (list[i] is ProfileCutObject)
         {
            //O if (list[i].processed == true)
            if (list[i].processed == true)
            {
               //O lmaxx += 0.5*list[i].tooldiameter;
               lmaxx += 0.5*list[i].tooldiameter;
               //O lmaxy += 0.5*list[i].tooldiameter;
               lmaxy += 0.5*list[i].tooldiameter;
               //O lminx -= 0.5*list[i].tooldiameter;
               lminx -= 0.5*list[i].tooldiameter;
               //O lminy -= 0.5*list[i].tooldiameter;
               lminy -= 0.5*list[i].tooldiameter;
            } else
            {
               //O lmaxx += list[i].tooldiameter;
               lmaxx += list[i].tooldiameter;
               //O lmaxy += list[i].tooldiameter;
               lmaxy += list[i].tooldiameter;
               //O lminx -= list[i].tooldiameter;
               lminx -= list[i].tooldiameter;
               //O lminy -= list[i].tooldiameter;
               lminy -= list[i].tooldiameter;
            }
         }
         //O else if (list[i] is FollowPathCutObject)
         else if (list[i] is FollowPathCutObject)
         {
            //O lmaxx += 0.5*list[i].tooldiameter;
            lmaxx += 0.5*list[i].tooldiameter;
            //O lmaxy += 0.5*list[i].tooldiameter;
            lmaxy += 0.5*list[i].tooldiameter;
            //O lminx -= 0.5*list[i].tooldiameter;
            lminx -= 0.5*list[i].tooldiameter;
            //O lminy -= 0.5*list[i].tooldiameter;
            lminy -= 0.5*list[i].tooldiameter;
         }

         //O if (isNaN(minx) || lminx < minx)
         if (isNaN(minx) || lminx < minx)
         {
            //O minx = lminx;
            minx = lminx;
         }
         //O if (isNaN(maxx) || lmaxx > maxx)
         if (isNaN(maxx) || lmaxx > maxx)
         {
            //O maxx = lmaxx;
            maxx = lmaxx;
         }
         //O if (isNaN(miny) || lminy < miny)
         if (isNaN(miny) || lminy < miny)
         {
            //O miny = lminy;
            miny = lminy;
         }
         //O if (isNaN(maxy) || lmaxy > maxy)
         if (isNaN(maxy) || lmaxy > maxy)
         {
            //O maxy = lmaxy;
            maxy = lmaxy;
         }
      }

      //O return new Rectangle(minx,miny,maxx-minx,maxy-miny);
      return new Rectangle(minx,miny,maxx-minx,maxy-miny);
   }
}

//O }
